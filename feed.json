{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Blog",
  "description": "다양한 주제에 대해서 이야기합니다. 개발, 기술, 일상, 주식, 부동산 등",
  "home_page_url": "https://leeduhan.github.io",
  "feed_url": "https://leeduhan.github.io/feed.json",
  "language": "ko-KR",
  "authors": [
    {
      "name": "lee du han",
      "url": "https://leeduhan.github.io"
    }
  ],
  "items": [
    {
      "id": "https://leeduhan.github.io/posts/claude/2025-07-11-claude-code-review/",
      "title": "AI는 내일자리의 강탈자가 아니다. 내 동료이고 스승이며 후임이다.",
      "content_html": "\n# AI는 내 일자리의 강탈자가 아니다. 내 동료이고 스승이며 후임이다.\n\nAI를 쓰면서 느낀 것이 AI는 내가 처음 학습을 시작할 때 내가 모르는 것을 알려주는 좋은 스승이자, 코드를 만들 때는 어떻게 짜는 것이 좋은지 서로 토론을 할 수 있는 좋은 동료이자 작업을 실제로 진행할 때는 어떻게 진행해야 하는지 학습시키고 그대로 짜는지 확인하는 후임 같은 존재라는 것이다.\n\n함께 가는 동반자인 것이지 나의 대체제는 아니다. 다만 이제 공부를 해야 하는 방향성이나 일하는 패러다임 및 방향은 많은 변화가 있을 것이라는 것은 확실하다. 하지만 그게 개발 자체를 대체하지는 않는다는 것도 사실이다.\n\n## 결국은 사람이 해야 한다\n\nAI가 모든 것을 다 해주는 것 같지만, 결국 무엇을 해야 할지 정하고 어떤 방식으로 어떤 기술을 사용할지 결정하는 것은 사람이다. AI는 그 과정에서 고민하고 학습하고 커뮤니케이션하는 비용을 획기적으로 줄여줄 뿐, 실제 의사결정과 방향성 제시는 사람의 몫이다.\n\n`비개발자도 AI의 도움으로 개발을 할 수 있다고 하지만, 이는 초기 단계에 국한된다` (근거 없음). 구현하려는 시스템이 복잡할수록, 다양한 예외 상황을 고려해야 할수록 기본적인 개발 지식 없이는 진행이 어려워진다.\n\n또한 문제 해결 방법이 적절하지 않다면, 다음 문제를 해결할 때 기존 코드 구조가 모래성처럼 무너질 가능성이 높다. 이를 방지하려면 AI가 올바른 학습을 해야 하고, **학습의 내용과 품질, 그리고 방향을 결정하고 지도하는 주체는 결국 사람**이어야 한다. \n\n## CLI 버전의 무한한 가능성\n\nCLI 버전이야말로 개발 AI 도구로서 가장 완벽하다고 생각한다. 터미널상에서 사용할 수 있는 기본 모듈이나 표준화된 도구들이 매우 많고, AI는 이러한 도구들을 매우 잘 활용한다. 그래서 일반적으로 이야기하는 워크플로우도 별다른 설정 없이 미리 정해진 프롬프트만 실행하면 웬만한 워크플로를 구축할 수 있다. 여기에 [MCP(Model Context Protocol)](https://modelcontextprotocol.io/)까지 연결하게 되면 가능성은 더욱 확장된다.\n\n예를 들어, 일정 시간마다 나에게 할당된 Jira 티켓이 있는지 확인해서 대기 중인 티켓만 골라 각각의 티켓을 해결하는 worktree를 생성하고, 개별로 작업을 수행한 후 그 결과를 PR로 자동 생성하는 워크플로우를 구축하고 싶다고 하자.\n\n먼저 Jira를 MCP로 연결하거나 curl로 [Jira REST API](https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/)에 접근해서 나에게 할당된 티켓 정보를 가져올 수 있다. 이 중에서 특정 상태인 티켓만 필터링하는 것도 가능하다. 이 과정도 API 문서만 제공해서 학습시키면 관련된 동작을 잘 수행할 것이고, 성공한 결과를 가지고 프롬프트로 만들어서 실행해 보면서 예외 케이스를 추가하면 된다.\n\n여기까지 되면 Jira 티켓 번호로 로컬에 브랜치를 생성하게 하면 된다. Git 터미널도 있고 [GitHub API](https://docs.github.com/en/rest)도 존재하기 때문에 이를 이용해서 브랜치를 생성하게 하고, Jira의 내용을 바탕으로 문제를 해결하는 코드를 스스로 작성하게 할 수도 있다.\n\n그다음에 작업이 완료되었다고 판단되면 PR을 원격에 생성하게 하면 된다. 개발자는 이 생성된 PR을 검토하거나 브랜치를 로컬로 가져와서 실행해 보면서 수정사항이나 미비 사항을 Jira에 남기거나 PR에 리뷰로 남기면, AI가 이를 다시 인식하게 할 수 있다 (인식시키는 방법은 Git 트리거를 사용하거나 일정 시간마다 호출하는 방식을 사용하면 된다).\n\n이 과정을 반복하다 보면 자잘한 이슈는 자동으로 해결되고, 사람은 AI가 처리하기 어려운 복잡한 문제나 제대로 구현되지 않은 부분만 처리하면 된다. 즉, 개발 생산성이 크게 향상되는 것이다.\n\n이렇게 터미널 기반으로 AI 개발 환경을 구현한다는 것은 생각보다 상상하는 모든 것을 가능하게 할 수도 있다.\n\n## 똑똑한 AI vs 성능이 낮은 AI\n\n[Claude](https://www.anthropic.com/claude), [Gemini](https://gemini.google.com/), [ChatGPT](https://openai.com/chatgpt), [Grok](https://grok.x.ai/) 등 여러 다양한 AI를 사용하다 보면 같은 질문에 전부 다른 답변을 한다. 답변의 품질은 결국 토큰을 얼마나 사용했느냐와 얼마나 많은 데이터로 학습되었느냐에 따라서 달라지는 것 같다.\n\n그렇다면 성능이 높은 AI가 항상 좋을까?\n\n실제로 업무에 활용해보면서 느낀 것은 고성능 AI는 결국 토큰을 많이 사용한다는 점이다. 즉, 비용적인 측면이 문제가 된다. 그렇다고 토큰 가격이 저렴한 모델을 사용하자니 답변의 품질이 문제가 된다.\n\n그렇다면 성능이 낮은 AI는 불필요한 것일까?\n\n사실은 그렇지 않다. 결국 사람이 질문을 하는 것이기에 질문의 수준과 난이도를 낮춰서 하면 토큰을 많이 사용하지 못하는 AI도 문제없이 작업을 해내고 원하는 품질의 결과를 낸다. \n\n즉, 문제를 잘게 쪼개서 해당 AI가 질문을 이해하고 처리할 수 있는 토큰 사용량에 맞게 작업을 시키면 답변의 품질은 크게 차이나지 않는다.\n\n결국 핵심은 **AI의 토큰 사용량에 맞게 얼마나 작업을 작게 쪼개서 분배하고 다시 합칠 수 있느냐, 그 설계를 어떻게 할 것이냐**이다.\n\n토큰을 많이 소모하는 고성능 모델은 추상적이거나 애매한 질문에도 좋은 품질을 보여주기 때문에 복잡한 문제를 해결하거나 조각나 있는 프로젝트를 하나로 통합할 때 사용하면 좋다.\n\n반면 문제를 조각내서 작업하는 것은 저렴한 AI를 이용한다면 전체적인 토큰 소모량은 확실히 줄어들 것이다.\n\n내 생각에는 소규모 작업에는 Gemini, Codex를 사용하고 이를 통합하거나 많은 추론이 필요한 작업은 Claude로 하는 것이 현재 시점에서 최적의 조합이 아닐까 싶다. \n\n만약 문제를 작게 나누어서 분배하고, 이를 검토하고 합치는 것까지 자동으로 할 수 있다면?\n그런 AI 파이프라인을 구축할 수 있다면?\n\n이것이 향후 발전 가능성이 높은 아키텍처가 아닐까? \n\n## AI 개발 워크플로우\n\n지금 내가 생각하는 AI 개발 워크플로우는 다음과 같다.\n\n```mermaid\n---\nconfig:\n  layout: dagre\n---\nflowchart TD\n    A[\"JIRA 등록\"] -- 웹훅 --> gemini\n    A[\"JIRA 등록\"] -- 웹훅 --> claude\n    A[\"JIRA 등록\"] -- 웹훅 --> user\n    subgraph gemini\n        g1{\"서브 테스크 작업별로 별도 worktree 생성\"}-->g2[[\"`작업진행`\"]]\n        g2-->g21[\"PR 생성\"]\n        g21-->g22[\"JIRA 상태 업데이트(작업완료)\"]\n        g22-->g23[\"worktree 종료\"]\n        g1-->g3[[\"`작업진행`\"]]\n        g3-->g31[[\"`end-to-end 실행`\"]]\n        g31-->g32[\"PR 생성\"]\n        g32-->g33[\"JIRA 상태 업데이트(작업완료)\"]\n        g33-->g34[\"worktree 종료\"]\n        g1-->g4[[\"`작업진행`\"]]\n        g4-->g41[[\"`tdd 실행`\"]]\n        g41-->g42[\"PR 생성\"]\n        g42-->g43[\"JIRA 상태 업데이트(작업완료)\"]\n        g43-->g44[\"worktree 종료\"]\n    end\n    subgraph claude\n        c1{\"JIRA 서브 테스크 진행상태 체크(전체 서브테스크가 작업완료 상태체크)\"}-->c2{\"서브테스크가 전부 작업완료 상태이면 worktree 생성\"}\n        c2-->c21[[\"`각 PR을 받아서 하나의 브랜치에 병합`\"]]\n        c21 --> c3[[\"`전체 화면 로직 개발`\"]]\n        c3 --> c4[[\"`end-to-end 테스트`\"]]\n    end\n    subgraph user\n        u1[\"슬랙등등.. 진행상황 전달\"]-->u2{\"전체로직이 완료되었는지 확인\"}\n        u2 --> u3{\"원하는대로 구현되었는지 확인\"}\n        u3 -. 구현 피드백 .-> u41[\"수정해야할 사항 확인\"]\n        u41 --> u42[\"JIRA 서브티켓 생성\"]\n        u3 -- 구현 완료 --> u4[\"배포\"]\n    end\n```\n\n단계별로 살펴보면:\n\n### 1. JIRA 티켓 등록\n\n티켓을 등록하는 방법은 어떤 것이든 상관없다. 현재 JIRA를 사용해서 작업할 뿐이고 (개인적으로 JIRA가 불편하다고 생각한다), 어떤 프로젝트 관리 프로그램을 사용하든 상관없다. 다만 웹훅을 지원해주는 것이 좋다.\n\n티켓 구조는 스토리를 Claude가 처리할 티켓으로 정의하고, 하위 티켓으로 잘게 쪼개서 등록해야 한다. 스토리 티켓의 내용에는 하위 티켓을 어떻게 연결해서 어떤 기능을 만들 것인지, 최종 결과가 무엇인지를 명확하게 작성해야 한다.\n\n하위 티켓은 Gemini가 가져가서 개별로 작업할 티켓이다. Gemini를 선택한 이유는 토큰 소모율이 현재 가장 낮다고 생각되기 때문이다. 토큰을 많이 사용하지 못하고 성능이 제한적이므로, 작업을 나눌 수 있는 만큼 잘게 쪼개서 상세하게 작성해야 한다.\n\n티켓에는 작업 후 TDD, end-to-end 테스트를 어떻게 할 것인지에 대한 내용도 포함해야 한다.\n\n### 2. 작업별로 worktree 생성\n\n웹훅은 Gemini와 Claude 둘 다에게 전달된다. Gemini는 서브태스크의 상태가 진행 중인 경우에만 작업을 수행한다. Claude는 전체 서브태스크의 상태를 확인한 후, 모든 서브태스크가 완료된 경우에만 작업을 수행한다.\n\nGemini는 JIRA 티켓의 내용을 바탕으로 정해진 규칙에 따라서 worktree를 생성한다.\n\n티켓 내용대로 작업을 진행하고 테스트까지 통과되면 PR을 생성하고, JIRA 티켓의 상태를 작업 완료로 업데이트한다.\n\n### 3. 작업 통합 worktree 생성\n\nClaude는 모든 서브태스크가 완료된 경우에만 작업을 수행한다.\n\nworktree는 스토리 티켓의 번호로 생성하고, 각 서브태스크의 PR을 받아서 하나의 브랜치에 병합한다.\n\n병합이 완료되면 스토리 티켓의 내용을 바탕으로 전체 로직을 개발한다. 이때 end-to-end 테스트를 진행하고, 테스트가 통과되면 PR을 생성하고 JIRA 티켓의 상태를 작업 완료로 업데이트한다.\n\n### 4. 최종 검토 및 배포\n\n사용자의 검토는 최종 PR이 생성되었다는 알림을 Slack이나 다른 매체로 전달받으면 시작한다.\n\n사용자는 해당 기능이 제대로 동작하는지, 원하는 대로 구현되었는지 확인한다. 만약 수정해야 할 사항이 있다면 JIRA 티켓에 하위 티켓을 생성해서 Gemini가 작업을 진행하게 한다. 구현이 완료되었다면 배포를 진행한다.\n\n이 과정에서 사용자가 어느 타이밍에 개입하고, 무엇을 확인하거나 작업할지에 따라서 다양한 변형된 워크플로우가 만들어질 수 있다. 하지만 전체적인 흐름은 위와 동일할 것이라고 생각한다.\n\n### 실제 경험담\n\n한 달 동안 Claude Code로 개발할 때 2~3개의 worktree를 동시에 열고 각각의 작업을 진행하면서 느낀 점은 위와 같은 워크플로우가 가장 효율적이라는 것이다.\n\nAI도 작업하는 동안은 코드를 고칠 수 없다. 코드를 중간에 고치게 되면 AI는 이를 다시 읽어서 분석하기 때문에 토큰 소모량만 증가하기 때문이다.\n\n그래서 AI가 작업하는 동안은 다른 worktree로 이동해서 다음 작업을 진행시키거나 작업된 사항을 검토해서 다시 피드백하는 형태로 진행했다.\n\n#### 생산성 측정 결과\n\n생산성의 기준은 **작업 완료까지 걸린 시간**으로 측정했다.\n\n**초기 단계**: 기준치(1.0) 대비 약 0.8 수준의 생산성\n- AI 사용법에 익숙하지 않아 오히려 시간이 더 오래 걸림\n\n**숙련 단계**: 기준치 대비 1.2~2.0 수준의 생산성 달성\n- **독립적인 작업**: 서로 연관성이 없는 작업으로 잘게 쪼개면 최대 2배까지 가능\n- **연관성 있는 작업**: 작업 간 의존성이 있거나 하나씩 검토하며 진행할 때는 1.2배 수준 (약 20% 향상)\n\n결론적으로 **어떤 워크플로우를 설계하고 사용하느냐에 따라서 생산성은 크게 달라질 수 있다**는 것을 확인했다.\n\n## AI 시대의 개발자\n\nAI 시대의 개발은 위와 같은 패러다임 전환이 필요하다. AI가 도와주는 개발 환경을 구축하고, AI가 효율적으로 작업할 수 있는 환경을 만들어야 한다.\n\n앞으로 개발자는 AI와 직접 협업할 수도 있고, AI의 작업을 검토하고 지도하는 역할을 할 수도 있을 것이다.\n\n어느 쪽이든 **AI와의 협업을 통해서 생산성을 극대화할 수 있느냐가 미래 개발자의 핵심 역량**이 될 것이다. ",
      "content_text": "AI 개발 도구를 사용하면서 느낀 AI의 역할과 개발자의 미래에 대한 고찰",
      "url": "https://leeduhan.github.io/posts/claude/2025-07-11-claude-code-review/",
      "date_published": "2025-07-11T00:00:00.000Z",
      "authors": [
        {
          "name": "zeke",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "AI",
        "Claude Code",
        "개발 도구",
        "생산성",
        "워크플로우",
        "Gemini"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/css/css-selecter-guide/",
      "title": "CSS 선택자 완벽 가이드: 초보자를 위한 친절한 설명",
      "content_html": "\n# 🎨 CSS 선택자 완벽 가이드\n\n안녕하세요! 오늘은 웹페이지를 꾸미는 핵심 도구인 **CSS 선택자**에 대해 알아보겠습니다. 색칠공부를 할 때 어떤 부분에 어떤 색을 칠할지 정하는 것처럼, CSS 선택자는 웹페이지의 어떤 부분을 꾸밀지 정하는 역할을 합니다.\n\n[MDN의 CSS 선택자 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors)에 따르면, CSS는 60개 이상의 선택자와 5개의 결합자를 제공하여 HTML 요소를 정교하게 선택할 수 있습니다.\n\n## 📚 목차\n\n1. [CSS 선택자란?](#1-css-선택자란)\n2. [기본 선택자](#2-기본-선택자)\n3. [속성 선택자](#3-속성-선택자)\n4. [가상 클래스](#4-가상-클래스)\n5. [결합자](#5-결합자)\n6. [CSS 우선순위](#6-css-우선순위)\n7. [실습 예제](#7-실습-예제)\n\n---\n\n## 1. CSS 선택자란?\n\n`학급에서 특정 학생을 부를 때를 생각해보세요. \"안경 쓴 학생\", \"빨간 옷 입은 학생\", \"첫 번째 줄에 앉은 학생\" 이런 식으로 특징을 말해서 부르잖아요? CSS 선택자도 비슷한 방식으로 작동합니다!`\n\n[W3C의 Selectors Level 3 명세](https://www.w3.org/TR/2018/REC-selectors-3-20181106/)에 정의된 바와 같이, CSS 선택자는 HTML 문서의 특정 요소들을 선택하여 스타일을 적용하는 패턴입니다.\n\n```css\n/* 이게 바로 CSS의 기본 구조입니다 */\n선택자 {\n  꾸미기: 방법;\n}\n\n/* 실제 예시 */\np {\n  color: blue; /* 모든 문단을 파란색으로 만들기 */\n}\n```\n\n---\n\n## 2. 기본 선택자\n\n### 🏷️ 태그 선택자 (Type Selector)\n\nHTML 태그 이름을 그대로 사용합니다. `마치 \"강아지\", \"고양이\"라고 종류별로 부르는 것과 같습니다.` [MDN 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors)에서는 이를 \"Type Selector\"라고 정의합니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 모든 제목을 빨간색으로 */\n      h1 {\n        color: red;\n      }\n\n      /* 모든 문단을 초록색으로 */\n      p {\n        color: green;\n      }\n\n      /* 모든 버튼을 크게 만들기 */\n      button {\n        font-size: 20px;\n        padding: 10px;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>빨간색 제목입니다</h1>\n    <p>초록색 문단입니다</p>\n    <button>큰 버튼입니다</button>\n  </body>\n</html>\n```\n\n### 🎯 클래스 선택자 (Class Selector)\n\n클래스는 여러 요소에게 같은 별명을 줄 수 있습니다. 점(.)으로 시작합니다! [MDN의 클래스 선택자 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors)에 따르면, 하나의 요소는 여러 개의 클래스를 가질 수 있습니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 점(.)으로 시작하는 것이 클래스 선택자입니다 */\n      .pretty {\n        background-color: pink;\n        padding: 10px;\n      }\n\n      .big {\n        font-size: 30px;\n      }\n\n      /* 두 개의 클래스를 가진 요소 */\n      .pretty.big {\n        border: 3px solid purple;\n      }\n    </style>\n  </head>\n  <body>\n    <p class=\"pretty\">예쁜 분홍 배경입니다</p>\n    <p class=\"big\">큰 글씨입니다</p>\n    <p class=\"pretty big\">예쁘고 크고 테두리도 있습니다</p>\n  </body>\n</html>\n```\n\n### 🆔 ID 선택자 (ID Selector)\n\nID는 딱 하나의 요소만 가질 수 있는 고유한 이름입니다. 샵(#)으로 시작합니다! [MDN 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors)에 명시된 대로, HTML 문서 내에서 ID는 고유해야 합니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 샵(#)으로 시작하는 것이 ID 선택자입니다 */\n      #special {\n        background-color: gold;\n        border: 5px dashed blue;\n        padding: 20px;\n      }\n\n      #main-title {\n        text-align: center;\n        font-size: 40px;\n        color: navy;\n      }\n    </style>\n  </head>\n  <body>\n    <h1 id=\"main-title\">특별한 제목입니다</h1>\n    <p id=\"special\">금색 배경의 특별한 문단입니다</p>\n  </body>\n</html>\n```\n\n### ✨ 전체 선택자 (Universal Selector)\n\n별표(\\*)는 \"모든 요소\"를 의미합니다. [MDN의 Universal Selector 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors)에서 설명하듯이, 이 선택자는 모든 타입의 HTML 요소를 선택합니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 페이지의 모든 요소에 적용 */\n      * {\n        margin: 0;\n        padding: 0;\n        font-family: \"맑은 고딕\", sans-serif;\n      }\n\n      /* 특정 영역 안의 모든 요소 */\n      .box * {\n        color: blue;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"box\">\n      <h2>박스 안의 제목</h2>\n      <p>박스 안의 문단</p>\n      <span>박스 안의 텍스트</span>\n    </div>\n  </body>\n</html>\n```\n\n---\n\n## 3. 속성 선택자\n\n속성 선택자는 태그가 가진 특별한 표시(속성)를 보고 선택해요. 대괄호 []를 사용해요! [MDN의 속성 선택자 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors)에서 다양한 속성 선택자 패턴을 확인할 수 있습니다.\n\n### 기본 속성 선택자\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* title 속성이 있는 모든 요소 */\n      [title] {\n        border-bottom: 2px dotted blue;\n        cursor: help;\n      }\n\n      /* type이 \"text\"인 input */\n      input[type=\"text\"] {\n        border: 2px solid green;\n        padding: 5px;\n      }\n\n      /* type이 \"submit\"인 input */\n      input[type=\"submit\"] {\n        background-color: blue;\n        color: white;\n        padding: 10px 20px;\n        border: none;\n        cursor: pointer;\n      }\n\n      /* href가 .pdf로 끝나는 링크 */\n      a[href$=\".pdf\"] {\n        color: red;\n      }\n\n      /* href가 .pdf로 끝나는 링크 뒤에 PDF 아이콘 추가 */\n      a[href$=\".pdf\"]:after {\n        content: \" 📄\";\n      }\n    </style>\n  </head>\n  <body>\n    <p title=\"마우스를 올려보세요!\">나는 설명이 있어요!</p>\n\n    <form>\n      <input type=\"text\" placeholder=\"텍스트를 입력하세요\" />\n      <input type=\"submit\" value=\"전송\" />\n    </form>\n\n    <a href=\"document.pdf\">PDF 문서 다운로드</a>\n  </body>\n</html>\n```\n\n### 고급 속성 선택자\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* class에 \"btn\"이 포함된 요소 */\n      [class*=\"btn\"] {\n        padding: 10px;\n        margin: 5px;\n        cursor: pointer;\n      }\n\n      /* class가 \"btn-\"로 시작하는 요소 */\n      [class^=\"btn-\"] {\n        border-radius: 5px;\n      }\n\n      /* data- 속성 활용 */\n      [data-color=\"red\"] {\n        color: red;\n      }\n\n      [data-color=\"blue\"] {\n        color: blue;\n      }\n\n      [data-size=\"big\"] {\n        font-size: 30px;\n      }\n    </style>\n  </head>\n  <body>\n    <button class=\"btn-primary\">주요 버튼</button>\n    <button class=\"btn-secondary\">보조 버튼</button>\n    <button class=\"small-btn\">작은 버튼</button>\n\n    <p data-color=\"red\" data-size=\"big\">빨갛고 큰 글씨입니다</p>\n    <p data-color=\"blue\">파란 글씨입니다</p>\n  </body>\n</html>\n```\n\n---\n\n## 4. 가상 클래스\n\n가상 클래스는 요소의 특별한 상태를 선택합니다. 콜론(:)으로 시작합니다! [MDN의 가상 클래스 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes)에 따르면, CSS는 80개 이상의 가상 클래스를 제공합니다.\n\n### 🖱️ 마우스 관련 가상 클래스\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 마우스를 올렸을 때 */\n      .hover-box {\n        background-color: lightblue;\n        padding: 20px;\n        transition: all 0.3s;\n      }\n\n      .hover-box:hover {\n        background-color: darkblue;\n        color: white;\n        transform: scale(1.1);\n      }\n\n      /* 링크 상태들 */\n      a {\n        text-decoration: none;\n        padding: 5px;\n      }\n\n      a:link {\n        color: blue; /* 방문하지 않은 링크 */\n      }\n\n      a:visited {\n        color: purple; /* 방문한 링크 */\n      }\n\n      a:hover {\n        background-color: yellow; /* 마우스 올렸을 때 */\n      }\n\n      a:active {\n        color: red; /* 클릭하는 순간 */\n      }\n\n      /* 버튼 효과 */\n      .magic-button {\n        background-color: green;\n        color: white;\n        padding: 15px 30px;\n        border: none;\n        font-size: 18px;\n        cursor: pointer;\n        transition: all 0.3s;\n      }\n\n      .magic-button:hover {\n        background-color: darkgreen;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n      }\n\n      .magic-button:active {\n        transform: translateY(2px);\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"hover-box\">마우스를 올려보세요! 색이 변해요!</div>\n\n    <p>\n      <a href=\"https://www.google.com\">구글 링크</a>\n      <a href=\"https://www.naver.com\">네이버 링크</a>\n    </p>\n\n    <button class=\"magic-button\">마법 버튼을 눌러보세요!</button>\n  </body>\n</html>\n```\n\n### 📝 폼 관련 가상 클래스\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 포커스 받았을 때 */\n      input:focus {\n        outline: 3px solid blue;\n        background-color: lightyellow;\n      }\n\n      /* 체크된 체크박스 */\n      input[type=\"checkbox\"]:checked {\n        width: 20px;\n        height: 20px;\n      }\n\n      /* 체크박스 옆 라벨 스타일 */\n      input[type=\"checkbox\"]:checked + label {\n        color: green;\n        font-weight: bold;\n      }\n\n      /* 비활성화된 요소 */\n      input:disabled {\n        background-color: #ccc;\n        cursor: not-allowed;\n      }\n\n      /* 필수 입력 필드 */\n      input:required {\n        border-left: 5px solid red;\n      }\n\n      /* 유효한/무효한 입력 */\n      input:valid {\n        border-color: green;\n      }\n\n      input:invalid {\n        border-color: red;\n      }\n    </style>\n  </head>\n  <body>\n    <form>\n      <p>\n        <input type=\"text\" placeholder=\"여기를 클릭해보세요!\" required />\n      </p>\n\n      <p>\n        <input type=\"checkbox\" id=\"agree\" />\n        <label for=\"agree\">동의합니다</label>\n      </p>\n\n      <p>\n        <input type=\"email\" placeholder=\"이메일 주소\" required />\n      </p>\n\n      <p>\n        <input type=\"text\" placeholder=\"비활성화된 입력창\" disabled />\n      </p>\n    </form>\n  </body>\n</html>\n```\n\n### 🔢 순서 관련 가상 클래스\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 첫 번째 자식 */\n      li:first-child {\n        color: red;\n        font-weight: bold;\n      }\n\n      /* 마지막 자식 */\n      li:last-child {\n        color: blue;\n        font-weight: bold;\n      }\n\n      /* n번째 자식 */\n      li:nth-child(3) {\n        background-color: yellow;\n      }\n\n      /* 짝수 번째 */\n      tr:nth-child(even) {\n        background-color: #f2f2f2;\n      }\n\n      /* 홀수 번째 */\n      tr:nth-child(odd) {\n        background-color: white;\n      }\n\n      /* 3의 배수 번째 */\n      div.box:nth-child(3n) {\n        background-color: pink;\n      }\n\n      /* 특정 타입의 첫 번째 */\n      p:first-of-type {\n        font-size: 20px;\n        color: green;\n      }\n    </style>\n  </head>\n  <body>\n    <ul>\n      <li>첫 번째 항목 (빨간색)</li>\n      <li>두 번째 항목</li>\n      <li>세 번째 항목 (노란 배경)</li>\n      <li>네 번째 항목</li>\n      <li>마지막 항목 (파란색)</li>\n    </ul>\n\n    <table border=\"1\" style=\"width: 100%;\">\n      <tr>\n        <td>1번 행</td>\n        <td>홀수</td>\n      </tr>\n      <tr>\n        <td>2번 행</td>\n        <td>짝수</td>\n      </tr>\n      <tr>\n        <td>3번 행</td>\n        <td>홀수</td>\n      </tr>\n      <tr>\n        <td>4번 행</td>\n        <td>짝수</td>\n      </tr>\n    </table>\n\n    <div>\n      <h2>제목</h2>\n      <p>첫 번째 문단 (크고 초록색)</p>\n      <p>두 번째 문단</p>\n    </div>\n  </body>\n</html>\n```\n\n### 🎯 유용한 가상 클래스\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* :not() - 제외하기 */\n      .menu li:not(:last-child) {\n        border-right: 1px solid #ccc;\n      }\n\n      /* :empty - 비어있는 요소 */\n      p:empty {\n        display: none;\n      }\n\n      /* :target - 앵커 대상 */\n      div:target {\n        background-color: yellow;\n        padding: 20px;\n        border: 2px solid orange;\n      }\n\n      /* ::before와 ::after - 가상 요소 */\n      .quote::before {\n        content: \"『\";\n        color: red;\n        font-size: 30px;\n      }\n\n      .quote::after {\n        content: \"』\";\n        color: red;\n        font-size: 30px;\n      }\n\n      /* 첫 글자 꾸미기 */\n      .story::first-letter {\n        font-size: 50px;\n        float: left;\n        line-height: 1;\n        margin-right: 5px;\n        color: blue;\n      }\n\n      /* 첫 줄 꾸미기 */\n      .story::first-line {\n        font-weight: bold;\n        color: green;\n      }\n    </style>\n  </head>\n  <body>\n    <ul class=\"menu\" style=\"list-style: none; display: flex; gap: 10px;\">\n      <li>홈</li>\n      <li>소개</li>\n      <li>서비스</li>\n      <li>연락처</li>\n    </ul>\n\n    <p></p>\n    <!-- 이 빈 문단은 보이지 않아요 -->\n\n    <p><a href=\"#section1\">섹션 1로 이동</a></p>\n    <div id=\"section1\">타겟이 된 섹션입니다!</div>\n\n    <p class=\"quote\">명언이 들어가는 곳</p>\n\n    <p class=\"story\">\n      옛날 옛적에 아주 작은 마을에 살고 있던 소녀가 있었습니다. 그 소녀는 매일\n      아침 일찍 일어나 정원에 물을 주었어요.\n    </p>\n  </body>\n</html>\n```\n\n---\n\n## 5. 결합자\n\n결합자는 선택자들 사이의 관계를 나타냅니다. `가족 관계처럼 생각하면 쉬워요!` [MDN의 결합자 문서](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Combinators)에서 4가지 주요 결합자를 설명합니다.\n\n### 후손 선택자 (Descendant Combinator)\n\n공백으로 표현되는 후손 선택자는 특정 요소의 모든 후손을 선택합니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* .container 안의 모든 p 태그 */\n      .container p {\n        color: blue;\n      }\n\n      /* nav 안의 모든 a 태그 */\n      nav a {\n        text-decoration: none;\n        color: white;\n        padding: 10px;\n        background-color: navy;\n      }\n\n      /* 여러 단계도 가능 */\n      .box div p {\n        background-color: yellow;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"container\">\n      <p>나는 파란색이에요!</p>\n      <div>\n        <p>나도 파란색이에요!</p>\n      </div>\n    </div>\n\n    <nav>\n      <a href=\"#\">메뉴1</a>\n      <a href=\"#\">메뉴2</a>\n      <div>\n        <a href=\"#\">서브메뉴</a>\n      </div>\n    </nav>\n\n    <div class=\"box\">\n      <div>\n        <p>나는 노란 배경이에요!</p>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n### 자식 선택자 (Child Combinator)\n\n`>` 기호로 표현되는 자식 선택자는 직접적인 자식 요소만 선택합니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 직접적인 자식만 선택 */\n      .parent > p {\n        border: 2px solid red;\n        padding: 10px;\n      }\n\n      /* ul의 직접 자식 li만 */\n      ul > li {\n        color: blue;\n        font-weight: bold;\n      }\n\n      /* 중첩된 li는 영향 없음 */\n      ul ul > li {\n        color: green;\n        font-weight: normal;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"parent\">\n      <p>나는 직접 자식이라 빨간 테두리가 있어요!</p>\n      <div>\n        <p>나는 손자라서 테두리가 없어요.</p>\n      </div>\n    </div>\n\n    <ul>\n      <li>\n        파란색 굵은 글씨\n        <ul>\n          <li>초록색 보통 글씨</li>\n          <li>초록색 보통 글씨</li>\n        </ul>\n      </li>\n      <li>파란색 굵은 글씨</li>\n    </ul>\n  </body>\n</html>\n```\n\n### 인접 형제 선택자 (Next-sibling Combinator)\n\n`+` 기호로 표현되는 인접 형제 선택자는 바로 다음에 오는 형제 요소를 선택합니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* h2 바로 다음의 p */\n      h2 + p {\n        color: red;\n        font-size: 18px;\n        font-style: italic;\n      }\n\n      /* 체크박스 바로 다음의 label */\n      input[type=\"checkbox\"] + label {\n        margin-left: 5px;\n        cursor: pointer;\n      }\n\n      input[type=\"checkbox\"]:checked + label {\n        color: green;\n        font-weight: bold;\n      }\n\n      /* 이미지 다음의 설명 */\n      img + p {\n        font-size: 12px;\n        color: gray;\n        font-style: italic;\n      }\n    </style>\n  </head>\n  <body>\n    <h2>제목입니다</h2>\n    <p>제목 바로 다음의 문단은 빨갛고 기울어져요!</p>\n    <p>그 다음 문단은 평범해요.</p>\n\n    <input type=\"checkbox\" id=\"check1\" />\n    <label for=\"check1\">체크해보세요!</label>\n\n    <img src=\"https://via.placeholder.com/200\" alt=\"샘플 이미지\" />\n    <p>이미지 설명입니다.</p>\n  </body>\n</html>\n```\n\n### 일반 형제 선택자 (Subsequent-sibling Combinator)\n\n`~` 기호로 표현되는 일반 형제 선택자는 이후에 오는 모든 형제 요소를 선택합니다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* h2 다음에 오는 모든 p */\n      h2 ~ p {\n        margin-left: 20px;\n        border-left: 3px solid blue;\n        padding-left: 10px;\n      }\n\n      /* 첫 번째 .special 다음의 모든 div */\n      .special ~ div {\n        background-color: lightgray;\n        padding: 10px;\n        margin: 5px 0;\n      }\n    </style>\n  </head>\n  <body>\n    <h2>주제</h2>\n    <p>첫 번째 문단</p>\n    <p>두 번째 문단</p>\n    <div>일반 div</div>\n    <p>세 번째 문단</p>\n\n    <div class=\"special\">특별한 div</div>\n    <div>회색 배경 1</div>\n    <div>회색 배경 2</div>\n    <p>일반 문단</p>\n    <div>회색 배경 3</div>\n  </body>\n</html>\n```\n\n---\n\n## 6. CSS 우선순위\n\n여러 CSS 규칙이 충돌할 때, 어떤 규칙이 적용되는지 알아봅시다! [MDN의 명시도(Specificity) 문서](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity)에서 자세한 계산 방법을 확인할 수 있습니다.\n\n### 📊 우선순위(명시도) 계산 방법\n\nCSS 명시도는 **ID-CLASS-TYPE** 형식 (A-B-C)으로 계산됩니다:\n\n- **A**: ID 선택자의 개수\n- **B**: 클래스 선택자, 속성 선택자, 가상 클래스의 개수  \n- **C**: 타입 선택자와 가상 요소의 개수\n\n`비교할 때는 점수를 더하는 것이 아니라, 왼쪽 컬럼부터 차례로 비교합니다!`\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 명시도 계산 예제 */\n\n      /* 타입 선택자 */\n      p {\n        color: black;\n      } /* 0-0-1 */\n\n      /* 클래스 선택자 */\n      .text {\n        color: blue;\n      } /* 0-1-0 → 0-0-1보다 우선 */\n\n      /* ID 선택자 */\n      #special {\n        color: red;\n      } /* 1-0-0 → 0-1-0보다 우선 */\n\n      /* 복합 선택자 계산 */\n      p.text {\n        color: green;\n      } /* 0-1-1 (클래스1개 + 타입1개) */\n      \n      div p.text {\n        color: purple;\n      } /* 0-1-2 (클래스1개 + 타입2개) → 0-1-1보다 우선 */\n      \n      #special .text {\n        color: orange;\n      } /* 1-1-0 (ID1개 + 클래스1개) → 0-1-2보다 우선 */\n\n      /* 속성 선택자도 CLASS 컬럼 */\n      p[class] {\n        color: yellow;\n      } /* 0-1-1 (속성1개 + 타입1개) */\n\n      /* 가상 클래스도 CLASS 컬럼 */\n      p:hover {\n        color: pink;\n      } /* 0-1-1 (가상클래스1개 + 타입1개) */\n    </style>\n  </head>\n  <body>\n    <p>기본 검정색 (0-0-1)</p>\n    <p class=\"text\">파란색이 이김 (0-1-0 > 0-0-1)</p>\n    <p id=\"special\">빨간색이 이김 (1-0-0 > 0-1-0)</p>\n    <p id=\"special\" class=\"text\">ID가 있어서 빨간색 유지</p>\n  </body>\n</html>\n```\n\n### 🎯 명시도 비교 원리\n\n```css\n/* 컬럼별 비교 방식 */\n.box          /* 0-1-0 */\np.box         /* 0-1-1 */\ndiv p.box     /* 0-1-2 */  ← 가장 높음 (C 컬럼이 가장 큼)\n\n#header       /* 1-0-0 */  ← 가장 높음 (A 컬럼이 있음)\n.nav .menu    /* 0-2-0 */\n.nav ul li    /* 0-1-2 */\n\n/* 컬럼별 비교 ✅ */\n/* 1-0-0 vs 0-2-0 → 첫 번째 컬럼에서 1 > 0이므로 #header 승리 */\n```\n\n### 🎯 우선순위 실전 예제\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      /* 같은 명시도일 때는 나중 선언이 이김 */\n      .box {\n        background-color: red;     /* 0-1-0 */\n      }\n      .box {\n        background-color: blue;    /* 0-1-0 → 나중 선언이므로 적용 */\n      }\n\n      /* 더 구체적인 선택자가 이김 */\n      .container .box {\n        background-color: green;   /* 0-2-0 → 0-1-0보다 우선 */\n      }\n\n      .box {\n        background-color: yellow;  /* 0-1-0 → 적용 안됨 */\n      }\n\n      /* !important는 최강 */\n      .box {\n        background-color: purple !important;\n      }\n\n      /* 인라인 스타일은 가장 높은 명시도 */\n      /* <div style=\"background-color: pink;\"> → 별도 우선순위 */\n\n      /* 상속은 명시도가 없음 (가장 약함) */\n      .parent {\n        color: red; /* 자식에게 상속 */\n      }\n\n      .parent p {\n        /* 상속받은 color보다 직접 지정이 우선 */\n        color: blue; /* 0-1-1 > 상속 */\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"container\">\n      <div class=\"box\">배경색: purple (!important 때문)</div>\n    </div>\n\n    <div class=\"parent\">\n      <p>빨간색 (상속)</p>\n      <p>파란색 (직접 지정)</p>\n      <p style=\"color: green;\">초록색 (인라인 스타일)</p>\n    </div>\n  </body>\n</html>\n```\n\n---\n\n## 7. 실습 예제\n\n### 🎮 인터랙티브 버튼 만들기\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .game-button {\n        background: linear-gradient(to bottom, #4caf50, #45a049);\n        border: none;\n        color: white;\n        padding: 15px 32px;\n        text-align: center;\n        text-decoration: none;\n        display: inline-block;\n        font-size: 16px;\n        margin: 4px 2px;\n        cursor: pointer;\n        border-radius: 12px;\n        box-shadow: 0 4px #999;\n        transition: all 0.1s;\n      }\n\n      .game-button:hover {\n        background: linear-gradient(to bottom, #45a049, #4caf50);\n      }\n\n      .game-button:active {\n        box-shadow: 0 2px #666;\n        transform: translateY(2px);\n      }\n\n      /* 다양한 색상의 버튼들 */\n      .red {\n        background: linear-gradient(to bottom, #f44336, #da190b);\n      }\n      .red:hover {\n        background: linear-gradient(to bottom, #da190b, #f44336);\n      }\n\n      .blue {\n        background: linear-gradient(to bottom, #008cba, #006687);\n      }\n      .blue:hover {\n        background: linear-gradient(to bottom, #006687, #008cba);\n      }\n    </style>\n  </head>\n  <body>\n    <button class=\"game-button\">기본 버튼</button>\n    <button class=\"game-button red\">빨간 버튼</button>\n    <button class=\"game-button blue\">파란 버튼</button>\n  </body>\n</html>\n```\n\n### 📋 체크리스트 만들기\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .checklist {\n        list-style: none;\n        padding: 0;\n      }\n\n      .checklist li {\n        padding: 10px;\n        margin: 5px 0;\n        background-color: #f9f9f9;\n        border-radius: 5px;\n        position: relative;\n        padding-left: 40px;\n      }\n\n      .checklist input[type=\"checkbox\"] {\n        position: absolute;\n        left: 10px;\n        top: 50%;\n        transform: translateY(-50%);\n        width: 20px;\n        height: 20px;\n        cursor: pointer;\n      }\n\n      .checklist input[type=\"checkbox\"]:checked + label {\n        text-decoration: line-through;\n        color: #999;\n      }\n\n      .checklist input[type=\"checkbox\"]:checked ~ .check-mark {\n        display: block;\n      }\n\n      .check-mark {\n        position: absolute;\n        right: 10px;\n        top: 50%;\n        transform: translateY(-50%);\n        color: green;\n        font-size: 20px;\n        display: none;\n      }\n\n      /* 완료된 항목 스타일 - :has()는 최신 브라우저에서 지원 */\n      .checklist li:has(input:checked) {\n        background-color: #e8f5e9;\n        opacity: 0.7;\n      }\n    </style>\n  </head>\n  <body>\n    <ul class=\"checklist\">\n      <li>\n        <input type=\"checkbox\" id=\"task1\" />\n        <label for=\"task1\">숙제하기</label>\n        <span class=\"check-mark\">✓</span>\n      </li>\n      <li>\n        <input type=\"checkbox\" id=\"task2\" />\n        <label for=\"task2\">방 청소하기</label>\n        <span class=\"check-mark\">✓</span>\n      </li>\n      <li>\n        <input type=\"checkbox\" id=\"task3\" />\n        <label for=\"task3\">책 읽기</label>\n        <span class=\"check-mark\">✓</span>\n      </li>\n    </ul>\n  </body>\n</html>\n```\n\n### 🎨 테이블 꾸미기\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .pretty-table {\n        border-collapse: collapse;\n        width: 100%;\n        margin: 20px 0;\n      }\n\n      .pretty-table th,\n      .pretty-table td {\n        border: 1px solid #ddd;\n        padding: 12px;\n        text-align: left;\n      }\n\n      .pretty-table th {\n        background-color: #4caf50;\n        color: white;\n        font-weight: bold;\n      }\n\n      /* 줄무늬 효과 */\n      .pretty-table tr:nth-child(even) {\n        background-color: #f2f2f2;\n      }\n\n      /* 마우스 오버 효과 */\n      .pretty-table tr:hover {\n        background-color: #ddd;\n      }\n\n      /* 첫 번째 열 강조 */\n      .pretty-table td:first-child {\n        font-weight: bold;\n        background-color: #e8f5e9;\n      }\n\n      /* 마지막 열 정렬 */\n      .pretty-table td:last-child {\n        text-align: center;\n      }\n    </style>\n  </head>\n  <body>\n    <table class=\"pretty-table\">\n      <tr>\n        <th>과목</th>\n        <th>점수</th>\n        <th>등급</th>\n      </tr>\n      <tr>\n        <td>국어</td>\n        <td>95</td>\n        <td>A</td>\n      </tr>\n      <tr>\n        <td>수학</td>\n        <td>88</td>\n        <td>B</td>\n      </tr>\n      <tr>\n        <td>영어</td>\n        <td>92</td>\n        <td>A</td>\n      </tr>\n      <tr>\n        <td>과학</td>\n        <td>86</td>\n        <td>B</td>\n      </tr>\n    </table>\n  </body>\n</html>\n```\n\n### 🎯 카드 레이아웃\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .card-container {\n        display: flex;\n        gap: 20px;\n        flex-wrap: wrap;\n        justify-content: center;\n      }\n\n      .card {\n        width: 200px;\n        border: 1px solid #ddd;\n        border-radius: 8px;\n        overflow: hidden;\n        transition: transform 0.3s, box-shadow 0.3s;\n      }\n\n      .card:hover {\n        transform: translateY(-5px);\n        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);\n      }\n\n      .card img {\n        width: 100%;\n        height: 150px;\n        object-fit: cover;\n      }\n\n      .card-content {\n        padding: 15px;\n      }\n\n      .card-content h3 {\n        margin: 0 0 10px 0;\n        color: #333;\n      }\n\n      .card-content p {\n        margin: 0;\n        color: #666;\n        font-size: 14px;\n      }\n\n      .card-content button {\n        margin-top: 10px;\n        width: 100%;\n        padding: 8px;\n        background-color: #4caf50;\n        color: white;\n        border: none;\n        border-radius: 4px;\n        cursor: pointer;\n        transition: background-color 0.3s;\n      }\n\n      .card-content button:hover {\n        background-color: #45a049;\n      }\n\n      /* 특별한 카드 */\n      .card.featured {\n        border-color: gold;\n        border-width: 3px;\n      }\n\n      .card.featured::before {\n        content: \"⭐ 추천\";\n        position: absolute;\n        top: 10px;\n        right: 10px;\n        background-color: gold;\n        color: white;\n        padding: 5px 10px;\n        border-radius: 15px;\n        font-size: 12px;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"card-container\">\n      <div class=\"card\">\n        <img\n          src=\"https://via.placeholder.com/200x150/FF6B6B/ffffff?text=카드1\"\n          alt=\"카드 이미지\"\n        />\n        <div class=\"card-content\">\n          <h3>일반 카드</h3>\n          <p>이것은 일반적인 카드입니다.</p>\n          <button>자세히 보기</button>\n        </div>\n      </div>\n\n      <div class=\"card featured\" style=\"position: relative;\">\n        <img\n          src=\"https://via.placeholder.com/200x150/4ECDC4/ffffff?text=카드2\"\n          alt=\"카드 이미지\"\n        />\n        <div class=\"card-content\">\n          <h3>특별한 카드</h3>\n          <p>이것은 추천 카드입니다!</p>\n          <button>자세히 보기</button>\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <img\n          src=\"https://via.placeholder.com/200x150/45B7D1/ffffff?text=카드3\"\n          alt=\"카드 이미지\"\n        />\n        <div class=\"card-content\">\n          <h3>또 다른 카드</h3>\n          <p>마우스를 올려보세요!</p>\n          <button>자세히 보기</button>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n---\n\n## 📚 정리하기\n\nCSS 선택자는 웹페이지를 꾸미는 핵심 도구입니다!\n\n### 기억해야 할 중요한 내용:\n\n1. **기본 선택자**\n\n   - 태그 선택자: `p`, `div`, `h1`\n   - 클래스 선택자: `.classname`\n   - ID 선택자: `#idname`\n   - 전체 선택자: `*`\n\n2. **속성 선택자**\n\n   - `[속성]`: 속성이 있는 요소\n   - `[속성=\"값\"]`: 정확히 일치\n   - `[속성^=\"시작\"]`: 시작 부분 일치\n   - `[속성$=\"끝\"]`: 끝 부분 일치\n   - `[속성*=\"포함\"]`: 포함하는 경우\n\n3. **가상 클래스**\n\n   - `:hover` - 마우스 올렸을 때\n   - `:active` - 클릭할 때\n   - `:focus` - 포커스 받을 때\n   - `:first-child` - 첫 번째 자식\n   - `:nth-child()` - n번째 자식\n\n4. **결합자**\n\n   - 공백 - 후손 선택자\n   - `>` - 자식 선택자\n   - `+` - 인접 형제 선택자\n   - `~` - 일반 형제 선택자\n\n5. **우선순위 (명시도)**\n   - A-B-C 형식으로 계산: ID개수-클래스개수-타입개수\n   - 왼쪽 컬럼부터 비교 (점수 덧셈 ❌)\n   - !important > 인라인 스타일 > ID(A) > 클래스(B) > 타입(C)\n   - 같은 명시도면 나중 선언이 적용\n\n더 자세한 내용은 [MDN의 CSS 선택자 종합 가이드](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors)와 [W3C CSS Selectors 명세](https://www.w3.org/TR/selectors-3/)를 참고하세요.\n",
      "content_text": "CSS 선택자의 모든 것을 쉽고 재미있게 배워보세요. 기본 선택자부터 고급 선택자까지 실습 예제와 함께 완벽하게 정리했습니다.",
      "url": "https://leeduhan.github.io/posts/css/css-selecter-guide/",
      "date_published": "2025-07-06T00:00:00.000Z",
      "authors": [
        {
          "name": "hanlee",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "CSS",
        "Web Development",
        "Frontend",
        "선택자",
        "웹 개발",
        "선택자 우선순위"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/tan-stack-query-use-query-vs-use-suspense-query/",
      "title": "TanStack Query: useQuery vs useSuspenseQuery 완벽 가이드",
      "content_html": "\n# TanStack Query: useQuery vs useSuspenseQuery\n\n## 들어가며\n\nReact 애플리케이션에서 서버 상태 관리는 항상 복잡한 문제였습니다. 로딩 상태, 에러 처리, 캐싱, 재시도 로직 등을 모두 고려해야 하죠. [TanStack Query](https://tanstack.com/query/latest)(구 React Query)는 이런 문제들을 우아하게 해결해주는 라이브러리입니다.\n\n[TanStack Query v5](https://tanstack.com/query/v5/docs/react/guides/migrating-to-v5)에서는 기존의 `useQuery`와 함께 새로운 `useSuspenseQuery` 훅이 도입되었습니다. 이 두 훅은 비슷해 보이지만 서로 다른 패러다임을 따르고 있어, 언제 어떤 것을 사용해야 할지 고민이 될 수 있습니다.\n\n이 글에서는 두 훅의 차이점을 실제 코드 예시와 함께 자세히 살펴보고, 각각의 장단점과 적절한 사용 시기를 알아보겠습니다.\n\n## useQuery vs useSuspenseQuery: 핵심 차이점\n\n### 1. 로딩 상태 관리 철학\n\n**useQuery**는 **명령형(Imperative)** 접근 방식을 취합니다. 개발자가 직접 로딩 상태를 확인하고 UI를 제어해야 합니다.\n\n**useSuspenseQuery**는 **선언형(Declarative)** 접근 방식을 취합니다. [React의 Suspense](https://react.dev/reference/react/Suspense) 시스템에 로딩 상태를 위임하고, 개발자는 성공 상태에만 집중할 수 있습니다.\n\n### 2. 주요 차이점 요약\n\n| 특징 | useQuery | useSuspenseQuery |\n|------|----------|------------------|\n| **로딩 상태** | `isPending`, `isLoading` 플래그로 수동 처리 | React Suspense로 자동 처리 |\n| **에러 처리** | 컴포넌트 내에서 직접 처리 | Error Boundary로 위임 |\n| **데이터 타입** | `TData \\| undefined` | `TData` (항상 정의됨) |\n| **조건부 실행** | `enabled` 옵션 지원 | `enabled` 옵션 불가 |\n| **이전 데이터 유지** | `placeholderData`, `keepPreviousData` | [React Transitions](https://react.dev/reference/react/useTransition) 권장 |\n| **TypeScript 안전성** | 타입 가드 필요 | 자동으로 타입 안전 보장 |\n\n## 실제 사용 예시로 비교해보기\n\n### 시나리오: 사용자 프로필 페이지\n\n먼저 공통으로 사용할 API 함수를 정의해보겠습니다.\n\n```typescript\n// API 함수\ninterface User {\n  id: string\n  name: string\n  email: string\n  avatar?: string\n}\n\nconst fetchUser = async (userId: string): Promise<User> => {\n  const response = await fetch(`/api/users/${userId}`)\n  if (!response.ok) {\n    throw new Error(`사용자를 찾을 수 없습니다: ${response.status}`)\n  }\n  return response.json()\n}\n\nconst fetchUserPosts = async (userId: string) => {\n  const response = await fetch(`/api/users/${userId}/posts`)\n  if (!response.ok) {\n    throw new Error(`게시글을 불러올 수 없습니다: ${response.status}`)\n  }\n  return response.json()\n}\n```\n\n### 1. useQuery 사용 예시\n\n```typescript\nimport { useQuery } from '@tanstack/react-query'\n\nfunction UserProfileWithUseQuery({ userId }: { userId: string }) {\n  const { \n    data: user, \n    isLoading, \n    isError, \n    error,\n    isSuccess \n  } = useQuery({\n    queryKey: ['user', userId],\n    queryFn: () => fetchUser(userId),\n    enabled: !!userId, // 조건부 실행 가능\n    staleTime: 5 * 60 * 1000, // 5분간 신선함 유지\n    retry: 3, // 3번 재시도\n  })\n\n  // 로딩 상태 처리\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center p-8\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500\"></div>\n        <span className=\"ml-2\">사용자 정보를 불러오는 중...</span>\n      </div>\n    )\n  }\n\n  // 에러 상태 처리\n  if (isError) {\n    return (\n      <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">\n        <h3 className=\"font-bold\">오류가 발생했습니다</h3>\n        <p>{error?.message}</p>\n        <button \n          onClick={() => window.location.reload()}\n          className=\"mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600\"\n        >\n          다시 시도\n        </button>\n      </div>\n    )\n  }\n\n  // 성공 상태 - 여전히 user가 undefined일 수 있어 타입 체크 필요\n  if (isSuccess && user) {\n    return (\n      <div className=\"bg-white shadow-lg rounded-lg p-6\">\n        <div className=\"flex items-center space-x-4\">\n          {user.avatar && (\n            <img \n              src={user.avatar} \n              alt={user.name}\n              className=\"w-16 h-16 rounded-full\"\n            />\n          )}\n          <div>\n            <h2 className=\"text-2xl font-bold text-gray-800\">{user.name}</h2>\n            <p className=\"text-gray-600\">{user.email}</p>\n          </div>\n        </div>\n        \n        {/* 종속 쿼리 - 사용자 정보가 있을 때만 실행 */}\n        <UserPostsWithUseQuery userId={user.id} />\n      </div>\n    )\n  }\n\n  return null\n}\n\n// 종속 쿼리 컴포넌트\nfunction UserPostsWithUseQuery({ userId }: { userId: string }) {\n  const { data: posts, isLoading, error } = useQuery({\n    queryKey: ['user-posts', userId],\n    queryFn: () => fetchUserPosts(userId),\n    enabled: !!userId, // 부모 쿼리가 성공한 후에만 실행\n  })\n\n  if (isLoading) {\n    return <div className=\"mt-4 text-gray-500\">게시글을 불러오는 중...</div>\n  }\n\n  if (error) {\n    return <div className=\"mt-4 text-red-500\">게시글 로딩 실패</div>\n  }\n\n  return (\n    <div className=\"mt-6\">\n      <h3 className=\"text-lg font-semibold mb-3\">최근 게시글</h3>\n      <div className=\"space-y-2\">\n        {posts?.map((post: any) => (\n          <div key={post.id} className=\"p-3 bg-gray-50 rounded\">\n            <h4 className=\"font-medium\">{post.title}</h4>\n            <p className=\"text-sm text-gray-600\">{post.excerpt}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n```\n\n### 2. useSuspenseQuery 사용 예시\n\n```typescript\nimport { useSuspenseQuery } from '@tanstack/react-query'\nimport { Suspense } from 'react'\nimport { ErrorBoundary } from 'react-error-boundary' // npm install react-error-boundary\n\nfunction UserProfileWithSuspenseQuery({ userId }: { userId: string }) {\n  // useSuspenseQuery는 enabled 옵션이 없음\n  const { data: user } = useSuspenseQuery({\n    queryKey: ['user', userId],\n    queryFn: () => {\n      if (!userId) {\n        // enabled 대신 queryFn에서 조건 처리\n        return Promise.resolve(null)\n      }\n      return fetchUser(userId)\n    },\n    staleTime: 5 * 60 * 1000,\n    retry: 3,\n  })\n\n  // 로딩이나 에러 상태 체크 불필요\n  // data는 항상 정의되어 있음 (TypeScript에서 User 타입으로 추론)\n  if (!user) {\n    return <div>유효하지 않은 사용자 ID입니다.</div>\n  }\n\n  return (\n    <div className=\"bg-white shadow-lg rounded-lg p-6\">\n      <div className=\"flex items-center space-x-4\">\n        {user.avatar && (\n          <img \n            src={user.avatar} \n            alt={user.name}\n            className=\"w-16 h-16 rounded-full\"\n          />\n        )}\n        <div>\n          <h2 className=\"text-2xl font-bold text-gray-800\">{user.name}</h2>\n          <p className=\"text-gray-600\">{user.email}</p>\n        </div>\n      </div>\n      \n      {/* 종속 쿼리 */}\n      <Suspense fallback={<div className=\"mt-4 text-gray-500\">게시글을 불러오는 중...</div>}>\n        <UserPostsWithSuspenseQuery userId={user.id} />\n      </Suspense>\n    </div>\n  )\n}\n\nfunction UserPostsWithSuspenseQuery({ userId }: { userId: string }) {\n  const { data: posts } = useSuspenseQuery({\n    queryKey: ['user-posts', userId],\n    queryFn: () => fetchUserPosts(userId),\n  })\n\n  return (\n    <div className=\"mt-6\">\n      <h3 className=\"text-lg font-semibold mb-3\">최근 게시글</h3>\n      <div className=\"space-y-2\">\n        {posts.map((post: any) => (\n          <div key={post.id} className=\"p-3 bg-gray-50 rounded\">\n            <h4 className=\"font-medium\">{post.title}</h4>\n            <p className=\"text-sm text-gray-600\">{post.excerpt}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n```\n\n### 3. 앱 전체 구조 비교\n\n```typescript\n// useQuery를 사용한 앱 구조\nfunction AppWithUseQuery() {\n  const [userId, setUserId] = useState<string>('123')\n\n  return (\n    <div className=\"max-w-2xl mx-auto p-4\">\n      <h1 className=\"text-3xl font-bold mb-6\">사용자 프로필 (useQuery)</h1>\n      \n      <div className=\"mb-4\">\n        <input \n          value={userId}\n          onChange={(e) => setUserId(e.target.value)}\n          placeholder=\"사용자 ID 입력\"\n          className=\"border border-gray-300 rounded px-3 py-2 w-full\"\n        />\n      </div>\n\n      {/* 각 컴포넌트에서 개별적으로 로딩/에러 처리 */}\n      <UserProfileWithUseQuery userId={userId} />\n    </div>\n  )\n}\n\n// useSuspenseQuery를 사용한 앱 구조\nfunction AppWithSuspenseQuery() {\n  const [userId, setUserId] = useState<string>('123')\n\n  return (\n    <div className=\"max-w-2xl mx-auto p-4\">\n      <h1 className=\"text-3xl font-bold mb-6\">사용자 프로필 (useSuspenseQuery)</h1>\n      \n      <div className=\"mb-4\">\n        <input \n          value={userId}\n          onChange={(e) => setUserId(e.target.value)}\n          placeholder=\"사용자 ID 입력\"\n          className=\"border border-gray-300 rounded px-3 py-2 w-full\"\n        />\n      </div>\n\n      {/* 전역적인 로딩/에러 처리 */}\n      <ErrorBoundary\n        fallback={({ error, resetErrorBoundary }) => (\n          <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">\n            <h3 className=\"font-bold\">오류가 발생했습니다</h3>\n            <p>{error.message}</p>\n            <button \n              onClick={resetErrorBoundary}\n              className=\"mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600\"\n            >\n              다시 시도\n            </button>\n          </div>\n        )}\n        onReset={() => window.location.reload()}\n      >\n        <Suspense fallback={\n          <div className=\"flex items-center justify-center p-8\">\n            <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500\"></div>\n            <span className=\"ml-2\">로딩 중...</span>\n          </div>\n        }>\n          {userId && <UserProfileWithSuspenseQuery userId={userId} />}\n        </Suspense>\n      </ErrorBoundary>\n    </div>\n  )\n}\n```\n\n## 복잡한 시나리오: 검색 기능 구현\n\n### useQuery로 검색 구현\n\n```typescript\nfunction SearchWithUseQuery() {\n  const [searchTerm, setSearchTerm] = useState('')\n  const [debouncedTerm, setDebouncedTerm] = useState('')\n\n  // 디바운싱\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedTerm(searchTerm)\n    }, 300)\n    return () => clearTimeout(timer)\n  }, [searchTerm])\n\n  const { \n    data, \n    isLoading, \n    error, \n    isFetching,\n    isPreviousData \n  } = useQuery({\n    queryKey: ['search', debouncedTerm],\n    queryFn: () => searchUsers(debouncedTerm),\n    enabled: debouncedTerm.length > 2, // 3글자 이상일 때만 검색\n    keepPreviousData: true, // 이전 결과 유지하면서 새 데이터 로딩\n    staleTime: 1000 * 30, // 30초\n  })\n\n  return (\n    <div className=\"p-4\">\n      <div className=\"relative\">\n        <input\n          type=\"text\"\n          value={searchTerm}\n          onChange={(e) => setSearchTerm(e.target.value)}\n          placeholder=\"사용자 검색...\"\n          className=\"w-full border rounded px-3 py-2\"\n        />\n        {isFetching && (\n          <div className=\"absolute right-2 top-2\">\n            <div className=\"animate-spin rounded-full h-5 w-5 border-b-2 border-blue-500\"></div>\n          </div>\n        )}\n      </div>\n\n      {searchTerm.length > 0 && searchTerm.length <= 2 && (\n        <p className=\"text-gray-500 mt-2\">3글자 이상 입력해주세요</p>\n      )}\n\n      {error && (\n        <p className=\"text-red-500 mt-2\">검색 중 오류가 발생했습니다</p>\n      )}\n\n      {isLoading && searchTerm.length > 2 && (\n        <div className=\"mt-4 text-center\">\n          <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto\"></div>\n          <p className=\"mt-2\">검색 중...</p>\n        </div>\n      )}\n\n      {data && (\n        <div className=\"mt-4\">\n          <div className=\"flex items-center justify-between mb-2\">\n            <p className=\"text-sm text-gray-600\">\n              {data.length}개의 결과\n            </p>\n            {isPreviousData && (\n              <span className=\"text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded\">\n                업데이트 중...\n              </span>\n            )}\n          </div>\n          <div className=\"space-y-2\">\n            {data.map((user: User) => (\n              <div key={user.id} className=\"p-3 border rounded hover:bg-gray-50\">\n                <h3 className=\"font-semibold\">{user.name}</h3>\n                <p className=\"text-gray-600\">{user.email}</p>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n```\n\n### useSuspenseQuery로 검색 구현\n\n```typescript\nfunction SearchWithSuspenseQuery() {\n  const [searchTerm, setSearchTerm] = useState('')\n  const [debouncedTerm, setDebouncedTerm] = useState('')\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedTerm(searchTerm)\n    }, 300)\n    return () => clearTimeout(timer)\n  }, [searchTerm])\n\n  return (\n    <div className=\"p-4\">\n      <input\n        type=\"text\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        placeholder=\"사용자 검색...\"\n        className=\"w-full border rounded px-3 py-2\"\n      />\n\n      {searchTerm.length > 0 && searchTerm.length <= 2 && (\n        <p className=\"text-gray-500 mt-2\">3글자 이상 입력해주세요</p>\n      )}\n\n      {debouncedTerm.length > 2 && (\n        <ErrorBoundary\n          fallback={({ error, resetErrorBoundary }) => (\n            <div className=\"mt-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded\">\n              <p>검색 중 오류가 발생했습니다: {error.message}</p>\n              <button \n                onClick={resetErrorBoundary}\n                className=\"mt-2 bg-red-500 text-white px-3 py-1 rounded\"\n              >\n                다시 시도\n              </button>\n            </div>\n          )}\n        >\n          <Suspense fallback={\n            <div className=\"mt-4 text-center\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto\"></div>\n              <p className=\"mt-2\">검색 중...</p>\n            </div>\n          }>\n            <SearchResults searchTerm={debouncedTerm} />\n          </Suspense>\n        </ErrorBoundary>\n      )}\n    </div>\n  )\n}\n\nfunction SearchResults({ searchTerm }: { searchTerm: string }) {\n  const { data } = useSuspenseQuery({\n    queryKey: ['search', searchTerm],\n    queryFn: () => searchUsers(searchTerm),\n    staleTime: 1000 * 30,\n  })\n\n  // React.startTransition을 사용하여 이전 결과 유지\n  return (\n    <div className=\"mt-4\">\n      <p className=\"text-sm text-gray-600 mb-2\">\n        {data.length}개의 결과\n      </p>\n      <div className=\"space-y-2\">\n        {data.map((user: User) => (\n          <div key={user.id} className=\"p-3 border rounded hover:bg-gray-50\">\n            <h3 className=\"font-semibold\">{user.name}</h3>\n            <p className=\"text-gray-600\">{user.email}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n```\n\n## 마이그레이션 고려사항\n\n### useQuery에서 useSuspenseQuery로 전환할 때\n\n1. **조건부 쿼리 처리**\n   ```typescript\n   // Before (useQuery)\n   const { data } = useQuery({\n     queryKey: ['user', userId],\n     queryFn: () => fetchUser(userId),\n     enabled: !!userId\n   })\n\n   // After (useSuspenseQuery)\n   // 조건부 렌더링으로 처리\n   if (!userId) return <div>사용자를 선택해주세요</div>\n   \n   const { data } = useSuspenseQuery({\n     queryKey: ['user', userId],\n     queryFn: () => fetchUser(userId)\n   })\n   ```\n\n2. **이전 데이터 유지**\n   ```typescript\n   // Before (useQuery)\n   const { data, isPreviousData } = useQuery({\n     queryKey: ['posts', page],\n     queryFn: () => fetchPosts(page),\n     keepPreviousData: true\n   })\n\n   // After (useSuspenseQuery + React Transitions)\n   const [page, setPage] = useState(1)\n   const [isPending, startTransition] = useTransition()\n   \n   const { data } = useSuspenseQuery({\n     queryKey: ['posts', page],\n     queryFn: () => fetchPosts(page)\n   })\n\n   const handlePageChange = (newPage: number) => {\n     startTransition(() => {\n       setPage(newPage)\n     })\n   }\n   ```\n\n3. **에러 처리 구조 변경**\n   ```typescript\n   // Before - 컴포넌트별 에러 처리\n   function Component() {\n     const { data, error } = useQuery({...})\n     if (error) return <ErrorMessage error={error} />\n     return <SuccessView data={data} />\n   }\n\n   // After - Error Boundary로 집중\n   function App() {\n     return (\n       <ErrorBoundary fallback={ErrorFallback}>\n         <Suspense fallback={<Loading />}>\n           <Component />\n         </Suspense>\n       </ErrorBoundary>\n     )\n   }\n   ```\n\n## 언제 어떤 것을 사용할까?\n\n### useQuery를 선택해야 하는 경우\n\n1. **세밀한 로딩 상태 제어가 필요한 경우**\n   - 여러 부분에서 다른 로딩 UI를 보여줘야 할 때\n   - 백그라운드 리페치 상태를 사용자에게 표시해야 할 때\n\n2. **조건부 쿼리가 많은 경우**\n   - 폼 데이터나 사용자 입력에 따라 쿼리를 켜고 꺼야 할 때\n   - 복잡한 의존성을 가진 쿼리들\n\n3. **점진적 마이그레이션**\n   - 기존 프로젝트에서 단계적으로 도입할 때\n   - 팀이 Suspense 패턴에 익숙하지 않을 때\n\n4. **이전 데이터 유지가 중요한 경우**\n   - 페이지네이션, 필터링 등에서 깜빡임 없는 UX가 필요할 때\n\n### useSuspenseQuery를 선택해야 하는 경우\n\n1. **선언적 코드를 선호하는 경우**\n   - 컴포넌트 로직을 단순화하고 싶을 때\n   - 로딩/에러 상태 처리를 외부로 위임하고 싶을 때\n\n2. **TypeScript 타입 안전성이 중요한 경우**\n   - `data`가 항상 정의되어 있음을 보장받고 싶을 때\n   - 타입 가드 코드를 줄이고 싶을 때\n\n3. **현대적인 React 패턴을 활용하고 싶은 경우**\n   - Concurrent Features와 함께 사용할 때\n   - Server Components와 Streaming을 활용할 때\n\n4. **일관된 에러 처리 전략이 있는 경우**\n   - 앱 전체에서 통일된 에러 UI를 제공하고 싶을 때\n\n## 성능 고려사항\n\n### 쿼리 워터폴 문제\n\n`useSuspenseQuery는 컴포넌트 트리에서 직렬로 실행되는 경향이 있습니다` (근거 없음):\n\n```typescript\n// 문제가 있는 패턴 - 직렬 실행\nfunction UserDashboard({ userId }: { userId: string }) {\n  const { data: user } = useSuspenseQuery({\n    queryKey: ['user', userId],\n    queryFn: () => fetchUser(userId)\n  })\n  \n  return (\n    <div>\n      <UserProfile user={user} />\n      <Suspense fallback={<div>프로젝트 로딩 중...</div>}>\n        <UserProjects userId={userId} /> {/* user 쿼리 완료 후 시작 */}\n      </Suspense>\n    </div>\n  )\n}\n\n// 개선된 패턴 - 병렬 실행\nfunction UserDashboard({ userId }: { userId: string }) {\n  return (\n    <Suspense fallback={<div>로딩 중...</div>}>\n      <UserProfile userId={userId} />\n      <UserProjects userId={userId} />\n    </Suspense>\n  )\n}\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data: user } = useSuspenseQuery({\n    queryKey: ['user', userId],\n    queryFn: () => fetchUser(userId)\n  })\n  return <div>{user.name}</div>\n}\n\nfunction UserProjects({ userId }: { userId: string }) {\n  const { data: projects } = useSuspenseQuery({\n    queryKey: ['projects', userId],\n    queryFn: () => fetchUserProjects(userId)\n  })\n  return <div>{projects.length} 프로젝트</div>\n}\n```\n\n### 캐시 활용\n\n두 훅 모두 같은 QueryClient 캐시를 공유하므로 함께 사용할 수 있습니다:\n\n```typescript\n// useQuery로 프리페치\nfunction HomePage() {\n  useQuery({\n    queryKey: ['user', 'current'],\n    queryFn: fetchCurrentUser,\n    staleTime: Infinity, // 캐시에 오래 보관\n  })\n  \n  return <Link to=\"/profile\">프로필 보기</Link>\n}\n\n// useSuspenseQuery로 사용 - 이미 캐시된 데이터 활용\nfunction ProfilePage() {\n  const { data: user } = useSuspenseQuery({\n    queryKey: ['user', 'current'],\n    queryFn: fetchCurrentUser\n  })\n  \n  return <UserProfile user={user} />\n}\n```\n\n## 실전 팁\n\n### 1. Error Boundary 최적화\n\n```typescript\nimport { QueryErrorResetBoundary } from '@tanstack/react-query'\n\nfunction App() {\n  return (\n    <QueryErrorResetBoundary>\n      {({ reset }) => (\n        <ErrorBoundary\n          onReset={reset}\n          fallbackRender={({ error, resetErrorBoundary }) => (\n            <div className=\"error-container\">\n              <h2>문제가 발생했습니다</h2>\n              <details>\n                <summary>오류 상세 정보</summary>\n                <pre>{error.message}</pre>\n              </details>\n              <button onClick={resetErrorBoundary}>\n                다시 시도\n              </button>\n            </div>\n          )}\n        >\n          <Router>\n            <Routes>\n              <Route path=\"/\" element={\n                <Suspense fallback={<PageLoader />}>\n                  <HomePage />\n                </Suspense>\n              } />\n            </Routes>\n          </Router>\n        </ErrorBoundary>\n      )}\n    </QueryErrorResetBoundary>\n  )\n}\n```\n\n### 2. 로딩 상태 최적화\n\n```typescript\n// 스켈레톤 UI 활용\nfunction ProductListSkeleton() {\n  return (\n    <div className=\"grid grid-cols-3 gap-4\">\n      {Array.from({ length: 6 }).map((_, i) => (\n        <div key={i} className=\"animate-pulse\">\n          <div className=\"bg-gray-300 h-48 rounded mb-2\"></div>\n          <div className=\"bg-gray-300 h-4 rounded mb-1\"></div>\n          <div className=\"bg-gray-300 h-4 w-2/3 rounded\"></div>\n        </div>\n      ))}\n    </div>\n  )\n}\n\nfunction ProductList() {\n  return (\n    <Suspense fallback={<ProductListSkeleton />}>\n      <ProductListContent />\n    </Suspense>\n  )\n}\n```\n\n### 3. 점진적 마이그레이션 전략\n\n```typescript\n// 1단계: useQuery + suspense 옵션 (v4 스타일)\nconst { data } = useQuery({\n  queryKey: ['user'],\n  queryFn: fetchUser,\n  suspense: true // [v5에서는 deprecated](https://tanstack.com/query/v5/docs/react/guides/migrating-to-v5#removed-features)\n})\n\n// 2단계: 조건부로 useSuspenseQuery 도입\nconst USE_SUSPENSE = process.env.NODE_ENV === 'development'\n\nfunction UserComponent() {\n  if (USE_SUSPENSE) {\n    return <UserWithSuspense />\n  }\n  return <UserWithUseQuery />\n}\n\n// 3단계: 완전 전환\nfunction UserComponent() {\n  const { data } = useSuspenseQuery({\n    queryKey: ['user'],\n    queryFn: fetchUser\n  })\n  return <UserProfile user={data} />\n}\n```\n\n## 결론\n\n`useQuery`와 `useSuspenseQuery`는 각각 다른 철학과 사용 사례를 가지고 있습니다.\n\n**useQuery**는 **제어와 유연성**을 제공합니다. 복잡한 로직, 조건부 쿼리, 세밀한 상태 관리가 필요한 경우에 적합합니다.\n\n**useSuspenseQuery**는 **단순함과 일관성**을 제공합니다. 현대적인 React 패턴을 활용하여 선언적이고 타입 안전한 코드를 작성하고 싶을 때 적합합니다.\n\n두 접근 방식 모두 장단점이 있으므로, 프로젝트의 요구사항, 팀의 경험, 그리고 장기적인 유지보수 전략을 고려하여 선택하는 것이 중요합니다. 무엇보다 두 훅은 같은 캐시를 공유하므로, 필요에 따라 혼용하여 사용할 수 있다는 점을 기억하세요.\n\nReact의 생태계가 [Concurrent Features](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react)와 Suspense 쪽으로 발전하고 있는 만큼, `useSuspenseQuery`를 익혀두는 것은 미래를 위한 좋은 투자가 될 것입니다.\n\n## 참고 자료\n\n- [TanStack Query 공식 문서](https://tanstack.com/query/latest)\n- [React Suspense 문서](https://react.dev/reference/react/Suspense)\n- [React Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)\n- [TanStack Query v5 마이그레이션 가이드](https://tanstack.com/query/v5/docs/react/guides/migrating-to-v5)",
      "content_text": "TanStack Query의 useQuery와 useSuspenseQuery 훅의 차이점을 실제 코드 예시와 함께 상세히 비교하고, 각각의 장단점과 적절한 사용 시기를 알아봅니다.",
      "url": "https://leeduhan.github.io/posts/tan-stack-query-use-query-vs-use-suspense-query/",
      "date_published": "2025-06-23T00:00:00.000Z",
      "authors": [
        {
          "name": "Zeke",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "TanStack Query",
        "React",
        "Suspense",
        "useSuspenseQuery",
        "useQuery"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/stock/2025-06-15/",
      "title": "새 정부 출범, 부동산과 주식시장은 어디로 갈까?",
      "content_html": "\n# 새 정부 출범, 부동산과 주식시장은 어디로 갈까?\n\n대통령이 바뀌면서 부동산과 주식시장이 어떻게 변할지 생각해봤습니다. 일단 부동산도 오르고 주식도 오를 것이라 생각했습니다.\n\n## 정권 교체 초기, 기대감이 시장을 움직인다\n\n[역대 정권교체 초기 증시흐름](https://www.ajunews.com/view/20250611162857661)을 보면, 이재명 정부 출범 이후 5거래일 동안 코스피가 7.71%, 코스닥은 6.21% 상승했습니다. 이전 정권 집권 초기 대비 수익률도 월등히 높았습니다.\n\n원래 정권이 바뀌면 초반 한두 달은 기대감에 오르는 것이 일반적입니다. 그런데 이번 대통령은 부동산과 주식에 대한 경험과 지식이 있어 보여서 나름의 설계가 있을 것으로 보입니다.\n\n## 새 정부의 부동산 전략: 자율 시장경제\n\n일단 부동산 가격을 강제로 잡으려는 대책을 내놓을 생각은 없어 보입니다. 자율시장경제에 맡기겠다는 입장입니다.\n\n`제 생각엔 그동안 부동산으로 돈이 몰린 이유가 백억, 천억대 자산가들이 세금이나 운영을 따져봤을 때 한국에서 운영하기 가장 좋은 것이 부동산이라서 많은 투자를 했다고 판단했을 것` (근거 없음) 이라 생각합니다.\n\n### 첫 번째 전략: 공급 확대\n\n많은 주택을 지을 것입니다. 수요와 공급이 자본주의의 기본이니까요. 공급을 늘려서 수요와 비등하게 맞추면 부동산 가격 폭등까지는 막을 수 있을 것입니다.\n\n[전문가들도 공급 확대 정책](https://www.bank-mall.co.kr/plus/blog/12033)을 할 것이라는 의견입니다. 전문가들은 이재명 정부의 부동산 공약이 \"공급 확대\"에 중점을 두고 있으며, 전 정부의 세금 위주 정책과는 다른 스탠스를 보인다고 분석합니다.\n\n## 핵심은 상법 개정을 통한 주식시장 혁신\n\n### 두 번째 전략: 주식시장 매력도 제고\n\n상법 개정을 통해서 백억대, 천억대 자산가들이 부동산보다 주식, 채권에서 더 많은 수익이나 고정된 현금을 창출할 수 있게 한다면 어떨까요? 돈이 부동산으로만 흐르지 않을 테니 부동산 집값도 잡고, 저평가된 주식시장도 올릴 수 있을 것입니다.\n\n현재 외국인이 단타 치는 시장을 진정한 투자 시장으로 바꿀 수도 있고요.\n\n### 상법 개정의 과제들\n\n그러려면 상법 개정이 성공적이어야 합니다. 현재 문제가 되는 것들이 너무 많습니다:\n\n- 기업에 돈이 있어도 배당하지 않는 문제\n  - [한국 기업 배당성향, 튀르키예보다 낮은 16위](https://v.daum.net/v/20250318000146874)\n  - [한국경제 보도](https://www.hankyung.com/article/2024052008351)에 따르면, 유가증권시장 상장사의 현금배당액은 10년 만에 15조원에서 41조원으로 늘었지만, 배당액 상위 20개사가 차지하는 비중은 65%로 소수 대기업에 집중되어 있습니다. 또한 한국 기업의 유동주식 비중(60.6%)은 미국(95%)·영국(93.9%)에 비해 크게 낮아 대주주 중심의 지배구조가 배당 확대를 가로막고 있습니다.\n- 기업분할 및 쪼개기 상장 같은 주주 가치 훼손 행위\n- 경영진의 배임, 횡령 등 회사 자산 유용에 대한 방지와 엄격한 처벌\n- 무차입 공매도 문제\n\n이 모든 것이 개선되어야 부동산도, 주식도 바로잡을 수 있게 될 것입니다.\n\n**모든 것이 상법 개정에 달려 있습니다.**\n\n## 배당 정책이 핵심이 될 이유\n\n부동산은 2~3년이면 완공 해서 분양하면 되지만, 상법 개정은 그동안 수많은 규제와 정책을 전부 손봐야 하니 쉽지 않을 것입니다. 그리고 국회에서 반대에 부딧쳐 계류된다면 더 심각해질 것입니다.\n\n더 많은 세금, 더 많은 제약으로 많은 돈을 가진 자산가들이 다시 주식을 외면한다면 자본은 다시 미국 시장으로 갈 수밖에 없게 됩니다.\n\n### 미국 배당 정책의 성공 사례\n\n[미국 배당 정책](https://eiec.kdi.re.kr/publish/columnView.do?cidx=13417&sel_year=2021&sel_month=07)을 보면, 미국 주식시장은 주주친화적인 기업이 많고, 분기 배당 정책으로 투자자들에게 월세처럼 꾸준한 현금 창출이 가능합니다. KB증권에 따르면 최근 10년간 미국 S&P500 상장사들의 배당 성향은 39%로 한국 유가증권시장(22%)에 비해 크게 높았습니다.\n\n미국 증시도 배당을 기본으로 하는 정책 때문에 외국인이 많은 투자를 하고 있고, 투자금을 빼지 않고 있다고 생각합니다.\n\n### 국내 배당 제도 개선 현황\n\n실제로 정부도 이를 인식하고 있습니다. [금융위원회의 배당 제도 개선](https://www.fsc.go.kr/po010101/79358)을 보면, 배당투자 활성화가 기업의 배당 확대로 이어져 다시 배당수익을 목적으로 하는 장기투자가 확대되는, 우리 자본시장의 선순환 구조가 마련될 것으로 기대됩니다.\n\n## 절호의 기회를 놓치지 말아야\n\n`미국이 외국인 배당세 등 여러 가지 이유로 혼란할 때 우리가 외국인 투자자들의 매력을 끌어서 돈을 유입시킬 절호의 기회가 아닐까` (근거 없음) 싶습니다.\n\n## 결론: 배당이 답이다\n\n이번 상법 개정의 핵심이 되어야 할 것은 배당일 것이라 생각합니다.\n\n[경제계도 같은 생각](https://www.sedaily.com/NewsView/2GQ7TA15CD/GC03)입니다. 대한상공회의소는 \"국회가 추진하는 상법 개정은 이사의 법적 책임에 대한 불확실성만 키워 소송 남발, 투자 위축, 혁신 저해 등 기업 경쟁력을 훼손할 것\"이라며 \"주주에게 직접적인 혜택이 갈 수 있는 주주배당 확대를 위한 조세제도를 마련해 밸류업을 모색해야 한다\"고 밝혔습니다.\n\n이번 상법 개정에서 배당이 얼마나 매력적이 되느냐가 중요한 과제라고 생각합니다.\n",
      "content_text": "정권 교체 이후 부동산과 주식시장의 변화 방향을 분석합니다. 공급 확대와 상법 개정을 통한 배당 정책이 핵심이 될 전망입니다.",
      "url": "https://leeduhan.github.io/posts/stock/2025-06-15/",
      "date_published": "2025-06-15T00:00:00.000Z",
      "authors": [
        {
          "name": "",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "주식",
        "부동산",
        "정책",
        "투자",
        "배당"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/claude/2025-06-15-development-workflow-with-cloud-code-4/",
      "title": "Claude Code로 개발 워크플로우 - Slash Command 설치 및 사용법",
      "content_html": "\n# Slash Command\n\nSlash Command는 Claude Code에서 **/**를 입력하면 사용 가능한 명령어 목록이 나타난다.\n\n내가 생각한 워크플로우 방법은 다음과 같았다.\n\n1. `/jira-worktree <지라URL> <대상브랜치 없으면 현재 브랜치>`\n2. 생성된 worktree 폴더로 이동\n3. pnpm i 로 패키지 설치\n4. `code .` 명령으로 VS Code 에디터 실행\n\n그런데 몇 가지 문제점이 있었다. \n\n1. worktree 폴더가 상위로 생성되었을 때 Claude Code의 보안 제한으로 접근 불가\n    - 현재 폴더에서 `.worktrees` 폴더를 생성하고 그 안에 worktree를 생성하는 방식으로 해결 가능 \n2. 명령 실행 시 토큰을 소모한다. (비용 증가)\n3. 셸 스크립트 실행인데 실행 및 최종 완료되는 시간이 많이 소요된다. (오래 걸린다)\n\n그래서 Slash Command를 사용하지 않고 [Git Subcommand](/posts/claude/2025-06-10-development-workflow-with-cloud-code-3)로 대부분을 변경했다.\n\n## ai-commit\n\nGit 커밋 메시지를 자동으로 생성하는 slash command이다. 현재 변경된 사항을 분석해서 메시지를 생성한다.\n\n이걸 설치하는 셸 스크립트를 작성해 달라고 했다. 등록하기 쉽고 삭제하기 쉬운 방법이 셸 스크립트라서 선택했다.\n\n설치와 삭제 모두 지원하는 스크립트이며, 전역과 현재 프로젝트 내 설치 둘 다 지원한다. \n\n셸 스크립트 실행 시 다음 위치에 생성되고 명령어 사용법은 다음과 같다.\n\n### 사용 설명서\n\n#### 설치 위치\n\n**글로벌 설치 (추천)**\n- 모든 프로젝트에서 사용 가능\n- 명령어: `/ai-commit`, `/aic`\n- 설치 위치: `~/.claude/commands/ai-commit.md`\n\n**프로젝트 설치**\n- 현재 프로젝트에서만 사용\n- 명령어: `/ai-commit`, `/aic`\n- 설치 위치: `.claude/commands/ai-commit.md`\n\n\n\n#### 동작 방식\n\n변경사항 감지 → 스마트 그룹화 → 커밋 메시지 생성 → 순차 커밋\n\n\n#### 스크립트 실행\n```bash\n$> bash ./ai_commit_manager_enhanced.sh\n```\n\n#### 글로벌 명령어\n\n```bash\n/ai-commit          # 기본 자동 분리 커밋\n/aic               # 짧은 별칭 (추천)\n```\n\n#### 프로젝트 명령어\n```bash\n/ai-commit      # 프로젝트별 설정\n/aic           # 짧은 별칭\n```\n\n#### 옵션들\n\n```bash\n/ai-commit                    # 기본 자동 분리 커밋\n/ai-commit --push            # 커밋 후 자동 push\n/ai-commit --dry-run         # 미리보기만 (커밋 안함)\n/ai-commit --single          # 모든 변경사항을 하나로 통합\n```\n\n```bash\n/ai-commit --lang en         # 영문 커밋 메시지\n/ai-commit --emoji           # 이모지 포함 (✨ feat, 🐛 fix 등)\n```\n\n```bash\n/ai-commit --push            # 가장 일반적인 사용법\n/ai-commit --single --push   # 단일 커밋 후 push\n/ai-commit --dry-run         # 테스트용 미리보기\n/ai-commit --emoji --lang en # 영문 + 이모지\n```\n\n\n#### Dry-run 모드\n```\n⚡ AI Commit (Dry-run) - 커밋 시뮬레이션\n\n📋 생성될 커밋 미리보기:\n\nCommit 1: feat(dashboard): 대시보드 차트 컴포넌트 추가\nFiles: src/components/Chart.tsx, src/hooks/useChartData.ts\n\nCommit 2: test(dashboard): 차트 컴포넌트 단위 테스트\nFiles: src/components/__tests__/Chart.test.tsx\n\n💡 실제 커밋을 하려면 --dry-run 옵션을 제거하고 다시 실행하세요.\n```\n\n#### 단일 커밋 모드\n```\n📦 모든 변경사항을 하나의 커밋으로 통합합니다...\n\n✨ 생성된 커밋 메시지:\nfeat(auth): 사용자 인증 시스템 구현\n\n- 로그인/로그아웃 기능 추가\n- JWT 토큰 기반 인증 구현  \n- 사용자 상태 관리 훅 개발\n- API 엔드포인트 및 타입 정의\n- 로그인 페이지 UI/UX 구현\n\n이 메시지로 커밋하시겠습니까? (Y/n/e[dit]):\n```\n\n#### 스마트 그룹화 규칙\n\n##### 파일 경로별 그룹화\n```\ncomponents/Login.tsx + components/Button.tsx → UI 컴포넌트 그룹\napi/auth.ts + types/user.ts → API 관련 그룹\nutils/validation.ts → 유틸리티 그룹\n```\n\n##### 기능별 그룹화\n```\nLogin.tsx + Login.test.tsx → 로그인 기능 그룹  \nUserProfile.tsx + useUserProfile.ts → 프로필 기능 그룹\n```\n\n##### 변경 타입별 그룹화\n```\n새 파일들 → feat 그룹\n버그 수정 → fix 그룹\n테스트 파일 → test 그룹\n```\n\n#### 커밋 타입 자동 결정\n\n| 타입 | 조건 | 예시 |\n|------|------|------|\n| `feat` | 새 기능, 컴포넌트, API | 새 로그인 페이지 |\n| `fix` | 버그 수정, 에러 처리 | try-catch 추가 |\n| `refactor` | 코드 구조 개선 | 함수 분리 |\n| `style` | CSS, 스타일링 | 버튼 스타일 수정 |\n| `test` | 테스트 코드 | 단위 테스트 추가 |\n| `docs` | 문서, 주석 | README 업데이트 |\n| `chore` | 설정, 빌드 | package.json 수정 |\n\n#### ⚡ 효율적인 워크플로우\n\n```bash\n# 개발 중\n$> git add .\n$> /ai-commit --dry-run        # 미리보기\n\n# 확인 후 커밋\n$> /ai-commit --push           # 커밋 + 푸시\n\n# 급할 때\n$> /ai-commit --single --push  # 단일 커밋 + 푸시\n```\n\n\n해당 스크립트는 [여기](/file/ai_commit_manager_enhanced.sh)에서 다운로드 가능하다. \n\n해당 스크립트는 Mac에 최적화되어 있으므로 다른 OS에서는 Claude Code에게 최적화를 요청하면 된다.\n",
      "content_text": "Claude Code의 Slash Command 기능 소개와 ai-commit 명령어 설치 가이드. 워크플로우 자동화를 위한 실용적인 팁과 문제점 해결 방법을 다룹니다.",
      "url": "https://leeduhan.github.io/posts/claude/2025-06-15-development-workflow-with-cloud-code-4/",
      "date_published": "2025-06-15T00:00:00.000Z",
      "authors": [
        {
          "name": "이두한",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "Claude Code",
        "클로드 코드",
        "바이브 코딩",
        "Vibe Coding",
        "Slash Command",
        "Git",
        "AI",
        "개발 도구",
        "자동화",
        "워크플로우",
        "ai-commit"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/claude/2025-06-10-development-workflow-with-cloud-code-3/",
      "title": "Claude Code로 개발 워크플로우 - Git Subcommand 설치 및 사용법",
      "content_html": "\n# Git Subcommand 설치\n\nGit Subcommand 스크립트를 실행해서 설치한다. 설치된 스크립트는 다음과 같이 사용한다.\n\n```bash\n# Jira 워크트리 생성\ngit wt-jira QAT-3349          # → fix/QAT-3349\ngit wt-jira PROJ-123          # → feature/PROJ-123\ngit wt-jira QAT-3349 develop  # develop에서 생성\ngit wt-jira https://company.atlassian.net/browse/QAT-3349  # → fix/QAT-3349\n\ngit wt-list                       # 목록 확인\ngit wt-list -v                    # 상세 정보\ngit wt-cleanup                    # 안전 정리\n\n# 도움말\ngit wt-jira --help\ngit wt-cleanup --help\ngit wt-list --help\n```\n\n자세한 매뉴얼은 git_worktree_manual.md를 참고하면 된다.\n\n스크립트의 동작 방식은 다음과 같다.\n\n## 1. git wt-jira QAT-xxxx\n\nQAT-xxxx로 시작하면 fix/QAT-xxxx로 worktree를 생성한다. 그외 티켓인경우 feature/티켓번호 로 브랜치가 생성된다.\n\n생성되는 폴더는 현재 폴더에 `.worktrees` 폴더를 만들고 그 안에 위치한다. 즉, `프로젝트root/.worktrees/fix-QAT-xxxx` 폴더가 생성된다.\n\n```bash\n$> git wt-jira https://company.atlassian.net/browse/QAT-3349  # → fix/QAT-3349\n```\n\n이 명령은 URL을 파싱해서 실행하므로 최종 명령은 동일하다.\n\n다음 명령 실행과 동일하다.\n\n```bash\n$> git worktree add .worktrees/fix-QAT-xxxx -b fix/QAT-xxxx [target브랜치]\n\n$> cd ./.worktrees/fix-QAT-xxxx # 생성된 worktree 폴더로 이동한다\n\n$> npm i # worktree는 새로운 프로젝트 폴더이므로 의존성을 다시 설치해야 한다. 내부적으로 패키지 매니저를 자동으로 인식해서 실행한다\n\n$> code . # VS Code를 실행한다\n```\n\nworktree 생성 시 `.worktrees` 폴더를 하위에 만드는 방식으로 결정한 것은 처음에 시도한 방법이 Slash Command였는데 이 방법은 Claude Code가 상위 디렉토리에 접근하지 못하는 문제가 있었다. 나중에 git worktree 관련 명령이 셸 스크립트로 바뀌면서 이 문제는 해결되었지만 `.worktrees` 폴더 밑에 모아놓은 게 관리하기 편하다는 것을 느껴서 이대로 구조를 유지했다.\n\n## 2. git wt-list\n\n아래 명령어의 단축어이다.\n\n```bash\n$> git worktree list\n```\n\n## 3. git wt-clean\n\n아래 명령어들의 단축어이다. 이 명령은 브랜치까지 삭제하지 않으므로 브랜치는 그대로 남아 있다.\n\n```bash\n$> git worktree remove [폴더절대경로]/.worktrees/fix-QAT-xxxx\n\n$> git worktree prune\n```\n\n## 셸 스크립트\n\n이 스크립트가 최종 완성본이다. 셸 등록 및 업데이트, 셸 스크립트 삭제가 하나의 명령어로 가능하다.\n\n해당 셸은 Mac에서 테스트되었다. 그 외 OS는 아마도 Claude의 도움이 필요하다.\n\n[installer_script 다운로드](/file/installer_script.sh)\n\n```sh\n# 다운로드 후 실행\n$> bash ./installer_script.sh\n```\n",
      "content_text": "Git Worktree를 활용한 효율적인 개발 환경 구성",
      "url": "https://leeduhan.github.io/posts/claude/2025-06-10-development-workflow-with-cloud-code-3/",
      "date_published": "2025-06-10T00:00:00.000Z",
      "authors": [
        {
          "name": "이두한",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "git worktree",
        "Claude Code",
        "클로드 코드",
        "바이브 코딩",
        "Vibe Coding",
        "Jira",
        "개발 환경",
        "자동화"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/claude/2025-06-10-development-workflow-with-cloud-code-1/",
      "title": "Claude Code로 개발 워크플로우",
      "content_html": "\n# Claude Code로 개발 워크플로우\n\nClaude Code를 쓰면서 느낀 점이 매우 똑똑한 주니어와 페어 프로그래밍을 하는 느낌이었다. 똑똑한데 개발의 방향이랑 뭘 개발해야 하는지 명확하게 이해하지 못하는 주니어랄까?\n\n기존에 많은 유저가 쓰는 라이브러리는 정말 잘 쓰지만 조금이라도 비주류의 라이브러리는 상상 코딩하거나 제대로 동작을 못 시키거나 해서 따로 관련 샘플이나 자료를 링크 리스트를 만들어서 학습을 시켜서 진행을 해야 했다.\n\n그리고 어떤 작업은 내가 작업 플랜을 세우고 시키는 것보다 내가 직접 개발하는 게 훨씬 빠르고 나은 것도 있었다.\n\n문제를 해결할 때 생각보다 시간이 걸릴 때도 있었다.\n\n그래서 생각한 게 멀티 작업이다. Claude Code를 멀티 터미널로 열고, 작업 플랜을 각각 업로드하고 작업하게 하고 단계별로 성공할 때마다 커밋을 남기게 학습시키고 난 내가 할 수 있는 작업을 하는 것이다.\n\n그리고 난 일정 시간마다 작업 결과물을 확인하고, 다시 지시를 수정하고 난 내 업무를 또 하는 멀티태스킹으로 한다면 생산성이 매우 올라갈 것이라고 판단했다.(이미 앤트로픽 영상에 있더라...)\n\n그래서 AI 개발 워크플로우를 찾아보고 나름대로 만들어 보기로 했다.\n\n## Claude Code를 이용한 전체 워크플로우\n\n1. Jira를 연동해서 이슈 생성 후 상태값이 '진행중'으로 변경되면 Jira 내용을 읽어서 작업 계획을 세우고, 작업을 완료하면 자동으로 draft PR을 생성한다.\n2. 생성된 PR을 리뷰하면서 빠진 부분이나 문제가 없는지 확인하고, draft를 해제한 PR을 업데이트한다.\n3. QA를 요청한다.\n\n이를 구현하려면 워크플로우를 연결할 수 있는 추가적인 요소가 필요했다. 서버나 인프라 등 다른 구성 요소들이 필요해서 이 워크플로우는 추후 개발하기로 했다. n8n과의 조합으로 가능해 보이지만, 이것만 집중할 수 없어서 다음 계획으로 전환했다.\n\n## 로컬에서 Claude Code로 개발 워크플로우\n\n1. Git Subcommand를 이용해서 Jira 링크를 주면 git worktree를 생성하고 프로젝트를 초기 설정한 후 VS Code를 실행한다. 이때 CLAUDE.md가 자동으로 로드되어 기본적인 내용이 설정된다.\n2. 작업에 따라서 다음과 같이 사전 작업을 진행한다.\n   1. 신규\n      - 빈 컴포넌트와 빈 페이지 또는 껍데기 컴포넌트를 만든다. (TDD의 경우는 테스트 케이스를 작성한다.)\n      - 컴포넌트의 상단에 앵커 주석 시스템을 이용해서 AI가 처리할 작업을 작성한다.\n   2. 이슈\n      - 이슈의 내용을 정리해서 관련된 파일 리스트와 해결해야 하는 문제를 정의한 후 복사해서 제공한다.\n3. git worktree를 이용해서 또다른 작업트리를 생성(1번 ~ 3번 반복)한다.\n4. CLAUDE.md에 mcp puppeteer(end-to-end)를 이용해서 브라우저 테스크까지 진행 콘솔창을 보고 자동수정하게 룰이 추가되어 있어야 한다. 에러가 안나면 작업이 대기 상태로 되게 한다.\n5. worktree별로 열린 에디터를 돌아다니면서 해당 이슈나 신규 기능이 제대로 작성되었는지 검토한다. 정상 동작할 때마다 Slash Command를 이용해서 현재 바뀐 코드 내용을 바탕으로 지금까지 작업한 내용을 커밋 메세지로 저장하게 한다.\n6. 검토가 완료되면 다음과정중 하나로 진행하게 된다.\n   1. 별도의 티켓으로 생성한경우 Git Subcommand를 이용해서 QA 브랜치에 머지 및 푸시하고 PR을 생성한다.\n   2. 하나의 티켓에서 별도의 작업으로 분리(하나의 티켓 작업인데 작업을 쪼개서 워크트리로 진행한경우이다. 예를 들면 함수나 기능별로 워크트리를 만들어서 작업 시키고 하나의 브랜치로 통합하는 경우)한경우 부모가 되는 브랜치에 머지 한다.\n7. 위 과정이 끝나면 git worktree를 삭제하고 워크트리에서 해제한다.\n\nClaude Code로 워크플로우를 만들 때 주요 구성 요소는 다음과 같다.\n\n1. [CLAUDE.md 작성](/posts/claude/2025-06-10-claude-md-guide)\n2. [Git Subcommand 설치](/posts/claude/2025-06-10-development-workflow-with-cloud-code-3)\n3. [Slash Command 설치](/posts/claude/2025-06-15-development-workflow-with-cloud-code-4)\n4. [사용후기](/posts/claude/2025-07-11-claude-code-review)\n\n## 참고 링크\n\n- [Claude Code: Best practices for agentic coding](https://www.anthropic.com/engineering/claude-code-best-practices)\n",
      "content_text": "Claude Code를 활용한 효율적인 개발 워크플로우 구축 방법",
      "url": "https://leeduhan.github.io/posts/claude/2025-06-10-development-workflow-with-cloud-code-1/",
      "date_published": "2025-06-10T00:00:00.000Z",
      "authors": [
        {
          "name": "이두한",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "Claude Code",
        "클로드 코드",
        "Jira",
        "git worktree",
        "CLAUDE.md",
        "개발 워크플로우",
        "바이브 코딩",
        "Vibe Coding"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/claude/2025-06-10-claude-md-guide/",
      "title": "Claude Code로 개발 워크플로우 - CLAUDE.md 작성법",
      "content_html": "\n# 1. CLAUDE.md 작성\n\n프로젝트 최상단의 CLAUDE.md는 md 폴더 내 상세 가이드를 안내하고, 전체적인 워크플로우 및 전체 규칙을 정리하는 파일이다.\n\n```\n# Bash commands\n- npm run build: Build the project\n- npm run typecheck: Run the typechecker\n\n# Architecture Decisions\n- Server Components by default, Client Components only when necessary\n- tRPC for type-safe API calls\n- Prisma for database access with explicit select statements\n- Tailwind for styling (no custom CSS files)\n\n# Code style\n- Use ES modules (import/export) syntax, not CommonJS (require)\n- Destructure imports when possible (eg. import { foo } from 'bar')\n\n# Patterns to Follow\n- Data fetching happens in Server Components\n- Client Components receive data as props\n- Use Zod schemas for all external data\n- Error boundaries around every data display component\n\n# Workflow\n- Be sure to typecheck when you’re done making a series of code changes\n- Prefer running single tests, and not the whole test suite, for performance\n\n# What NOT to Do\n- Don't use useEffect for data fetching\n- Don't create global state without explicit approval\n- Don't bypass TypeScript with 'any' types\n```\n\n기본 형식이 위와 같이 되어 있는데 나는 다른 블로그에서 제공한 [AGENTS.md](https://github.com/julep-ai/julep/blob/dev/AGENTS.md)의 내용을 참고하여 프로젝트 root의 [CLAUDE.md](/file/CLAUDE-Guide.md)를 작성해 클로드 코드에 요청했다.\n\n그리고 이를 프로젝트에 적용한 후,\n\n1. 프로젝트별 정보 커스터마이징: 대괄호로 표시된 부분을 실제 프로젝트 정보로 수정\n2. 도메인 용어 추가: 프로젝트 특화 용어들을 도메인 사전에 추가\n3. 기술 스택 업데이트: 실제 사용하는 기술 스택으로 수정\n4. 팀 컨벤션 반영: 팀의 코딩 스타일과 워크플로우에 맞게 조정\n\n을 해달라고 해서 기본 CLAUDE.md 내용을 생성한 뒤 다음과 같이 파일을 분리했다.\n\n1. CLAUDE.md 작성(root)\n2. 하위 문서 작성(root/md)\n   1. 코딩가이드.md\n   2. 기술 스택 및 아키텍처.md\n   3. 프로젝트 구조.md\n   4. 빌드 및 실행 명령어.md\n   5. 앵커 주석 시스템.md\n   6. 개발 워크플로우.md\n   7. AI 개발 가드레일.md\n      - 필수 : **황금률**: 구현 세부 사항이나 요구 사항에 대해 확신이 서지 않을 때는 항상 가정을 하지 말고 개발자와 상의하세요.\n      - AI의 접근 범위를 반드시 명시해서 어디까지 가능하고 어디를 하면 안되는지 명시\n\n이런 식으로 분리해서 클로드 코드가 처음 로딩할 때 기본적으로 학습할 것을 정리해 놓는다. 그리고 반드시 해당 파일들은 임의로 수정하지 못하게 접근 가이드라인을 설정해야 한다.\n\n이렇게 파일을 나누어 저장하는 이유는 토큰 때문이다. CLAUDE.md 파일 내용이 커질수록 claude code가 로드될 때마다 학습에 들어가는 토큰 비용이 증가한다. 그래서 되도록 CLAUDE.md 파일에는 필수적인 내용만 들어가고\n\n그 외 내용은 별도 파일로 제공한 뒤 작업 플랜 파일이나, 컴포넌트 파일에서 어디를 미리 참고를 해서 작업을 해야 하는지를 명시해서 작업을 시켜야 한다.\n\n앵커 코멘트 사용 예\n\n```ts\n/** \nAIDEV-NOTE: 다음 경로의 파일 리스트의 내용을 먼저 읽고 작업을 시작 \n - /md/ai-development-guardrails.md\n - /md/design-system-guide.md\n - /md/coding-guide.md\n - 참고할 컴포넌트 파일 경로\n - 참고할 외부링크\n*/\n\n/** \nAIDEV-TODO : 이 컴포넌트의 기능을 정의한다. 그리고 작업 순서 및 확인 방법을 정의한다. 실질적인 작업플랜이 적히는곳\n*/\nconst CompomentName = () => {};\n```\n\n작업 플랜 예\n\n```md\n# 작업전 학습 리스트\n\n- /md/ai-development-guardrails.md\n- /md/design-system-guide.md\n- /md/coding-guide.md\n- 참고할 컴포넌트 파일 경로\n- 참고할 외부링크\n\n# 작업 목표\n\n# 검증 방법\n```\n\n이런 식으로 미리 컴포넌트 껍데기를 만들거나 작업 플랜에 작성해서 클로드에 제공을 하고 작업을 시키는 게 토큰 소모 면에서 유리하다는 게 실험한 결론이었다.\n\n# CLAUDE.md 템플릿\n\n````md\n# CLAUDE.md - AI Assistant Documentation\n\n이 문서는 프로젝트에서 작업하는 AI 어시스턴트(Claude 등)를 위한 주요 참조 문서입니다. 프로젝트 구조, 코딩 규칙, 개발 가이드라인에 대한 필수 정보를 담고 있습니다.\n\n## Project Overview\n\n해당 프로젝트는 여러 애플리케이션을 포함하는 모노레포입니다:\n\n- **Web App** (`apps/web/`) - 메인 웹 애플리케이션\n- **Admin Panel** (`apps/admin/`) - 관리자 인터페이스\n- **Storybook** (`apps/storybook/`) - 컴포넌트 문서화\n\n## Quick Start\n\n**⚠️ 중요**: 코드 수정 작업을 시작하기 전에 반드시 [AI Development Guardrails](./md/ai-development-guardrails.md) 문서를 읽고 최신 자동화 규칙을 확인하세요.\n\n특정 주제에 대한 자세한 정보는 `/md` 디렉토리의 문서를 참조하세요:\n\n1. [AI Development Guardrails](./md/ai-development-guardrails.md) - **우선 필독** AI 지원 개발을 위한 가이드라인\n2. [Coding Guide](./md/coding-guide.md) - 코드 스타일과 규칙\n3. [Design System Guide](./md/design-system-guide.md) - 디자인 시스템 사용법\n4. [Project Structure](./md/project-structure.md) - 디렉토리 구조와 파일 조직\n5. [Build and Run Commands](./md/build-and-run-commands.md) - 개발 및 배포 명령어\n6. [Development Workflow](./md/development-workflow.md) - Git 워크플로우와 개발 프로세스\n\n## Core Principles\n\n### 1. Code Quality\n\n- 기존 패턴과 규칙을 따르세요\n- 현재 코드베이스와 일관성을 유지하세요\n- 깨끗하고, 읽기 쉽고, 유지보수 가능한 코드를 작성하세요\n\n### 2. Testing\n\n- 새로운 테스트를 작성하기 전에 기존 테스트 패턴을 확인하세요\n- 변경사항을 커밋하기 전에 테스트를 실행하세요\n- 각 앱에 적절한 테스트 명령어를 사용하세요\n\n## Important Commands\n\n```bash\n# Development\npnpm dev:web        # 웹 앱 실행\npnpm dev:admin      # 관리자 패널 실행\npnpm storybook      # Storybook 실행\n\n# Testing\npnpm test           # 모든 테스트 실행\npnpm lint           # 린팅 실행\n\n# Building\npnpm build          # 모든 앱 빌드\n```\n\n## Getting Help\n\n이 프로젝트에서 작업할 때:\n\n1. `/md`의 상세 문서를 참조하세요.\n2. 요구사항이 불명확할 때는 명확히 물어보세요.\n3. 중요한 변경사항은 문서화하세요.\n4. 커밋 메시지 규칙을 따르세요.\n5. [AI Development Guardrails](./md/ai-development-guardrails.md)를 항상 따르세요\n````\n\n내용 대부분도 claude code가 생성한 것이다. 그 이후 프로젝트에 맞게 수정을 했다.\n\n# AI 지원 개발을 위한 가이드라인 (/md/ai-development-guardrails.md 파일내용)\n\nAI에게 어디까지 가능하고 어디를 하면 안 되는지를 가이드하는 문서이다. 항상 학습을 해야 하는 문서라고 생각한다. 내용을 필요한것만 남기고 사용하는것을 추천한다.\n\n핵심은 The Golden Rule 부분이다. 임의로 진행하거나 바꾸어서는 안되는 룰 설정을 하는 부분이다.\n\n````md\n# AI Development Guardrails\n\n이 문서는 프로젝트에서 AI 지원 개발을 위한 가이드라인, 경계, 모범 사례를 설정합니다.\n\n## 목차\n\n1. [The Golden Rule](#the-golden-rule)\n2. [AI Assistant 자동화 규칙](#ai-assistant-자동화-규칙)\n3. [AI Access Scope](#ai-access-scope)\n4. [Permitted Activities](#permitted-activities)\n5. [Restricted Activities](#restricted-activities)\n6. [Code Quality Standards](#code-quality-standards)\n7. [Safety Guidelines](#safety-guidelines)\n8. [Collaboration Principles](#collaboration-principles)\n9. [Decision Making Framework](#decision-making-framework)\n10. [Documentation Requirements](#documentation-requirements)\n11. [Escalation Procedures](#escalation-procedures)\n\n## The Golden Rule\n\n> **🏆 황금 규칙**: 구현 세부사항이나 요구사항이 불확실할 때는 추측하지 말고 항상 개발자에게 문의하세요. 잘못 구현하는 것보다 먼저 명확히 하는 것이 낫습니다.\n\n### 1. Non-negotiable golden rules\n\n| #:  | AI _may_ do                                                          | AI _must NOT_ do                                                                          |\n| --- | -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |\n| G-0 | 프로젝트와 관련된 불확실한 사항에 대해 변경 전 개발자에게 확인 요청  | ❌ 프로젝트별 특정 사항이나 기능/결정에 대한 맥락이 없을 때 도구 사용하거나 변경사항 작성 |\n| G-1 | 관련 소스 디렉토리(`src/`, `content/`, `public/`) 내에서만 코드 생성 | ❌ 테스트 파일, 설정 파일(`*.config.*`, `package.json`) 건드리기                          |\n| G-2 | 중요한 편집 코드 근처에 **`AIDEV-NOTE:` 앵커 코멘트** 추가/업데이트  | ❌ 기존 `AIDEV-` 코멘트 삭제하거나 손상시키기                                             |\n| G-3 | 린트/스타일 설정(`eslint.config.mjs`, `next.config.ts`) 준수         | ❌ 다른 스타일로 코드 재포맷                                                              |\n| G-4 | 300줄 이상 또는 3개 파일 이상 변경 시 **확인 요청**                  | ❌ 대규모 모듈 리팩토링을 사람 지도 없이 진행                                             |\n| G-5 | 현재 작업 컨텍스트 내에서만 작업. 새 작업 시작 시 개발자에게 알림    | ❌ 이전 프롬프트의 작업을 \"새 작업\" 후에도 계속 진행                                      |\n| G-6 | CLAUDE.md 파일 수정이 필요할 때 사용자에게 수정 내용 제안            | ❌ **CLAUDE.md 파일을 사용자의 명시적 지시 없이 직접 수정**                               |\n| G-7 | 환경 변수나 설정 파일 관련 가이드 제공 및 확인 요청                  | ❌ **.env, 환경 설정 파일(`*.config.*`, `docker-compose.yml` 등)을 임의로 수정**          |\n\n### 이것이 중요한 이유\n\n- 추측에 기반한 **잘못된 구현을 방지**\n- 재작업과 디버깅을 피하여 **시간 절약**\n- **코드 품질**과 프로젝트 일관성 유지\n- AI와 인간 개발자 간의 **신뢰 구축**\n- 요구사항이 **올바르게 이해되도록 보장**\n\n### 언제 문의해야 하는가\n\n- **불명확한 요구사항**이나 명세\n- **모호한 사용자 스토리**나 티켓\n- **여러 구현 방식**이 가능한 경우\n- **Breaking changes**나 주요 리팩토링\n- **보안에 민감한** 코드 수정\n- **성능이 중요한** 구현\n- **외부 연동**이나 API 변경\n\n## AI Assistant 자동화 규칙\n\n이 섹션은 AI Assistant가 자동으로 수행해야 하는 규칙과 프로세스를 정의합니다.\n\n### 세션 시작 시 안내\n\n새로운 세션에서 코드 수정 관련 작업이 감지되면:\n\n- \"코드 수정 작업을 하시나요? AI Development Guardrails를 먼저 확인하시겠습니까?\"\n- React 컴포넌트, 에러 수정, 버그 해결 등의 키워드 감지 시 자동 안내\n\n### 컨텍스트 기반 자동 로드\n\n다음 키워드 감지 시 AI Development Guardrails 자동 참조:\n\n- `컴포넌트`, `component`, `수정`, `fix`, `에러`, `error`\n- `React`, `Next.js`, `서버`, `클라이언트`\n- `Puppeteer`, `테스트`, `검증`, `브라우저`\n\n### 핵심 규칙 요약 (Quick Reference)\n\n**⚡ 자동 검증 트리거 조건:**\n\n- React 컴포넌트 파일(`.tsx`, `.jsx`) 수정 시 무조건 자동 실행\n- `src/components/`, `src/app/` 내 파일 수정 시 무조건 자동 실행\n- 에러 메시지에 컴포넌트 이름이 포함된 경우 무조건 자동 실행\n\n**🔧 포트 번호 자동 탐지 순서:**\n\n1. 기본 포트 3000 실행 상태 확인 (최우선) - `lsof -i :3000`\n2. 서버 실행 중이면 → 3000 포트 사용, 서버 유지\n3. 서버 미실행이면 → 포트 탐지 후 서버 시작:\n   - `apps/web/.env.local` 파일의 `PORT` 환경변수 확인\n   - `apps/web/.env.qa1` 파일의 `PORT` 환경변수 확인\n   - `apps/web/package.json`의 dev 스크립트에서 포트 추출\n   - 포트 탐지 후 서버 시작 (사용자에게 실행 명령어 확인)\n\n**🚨 강제 자동화 체크리스트 (React 컴포넌트 수정 시 필수!):**\n\n```\n✅ 1. 트리거 조건 충족 확인 (무조건 확인)\n✅ 2. 포트 번호 자동 탐지 실행 (3000 우선 → 탐지)\n✅ 3. 컴포넌트 사용 경로 탐지 실행 (Grep으로 import 검색)\n✅ 4. MCP Puppeteer 브라우저 테스트 실행 (필수! 절대 생략 금지)\n✅ 5. 특정 에러 해결 확인 (수정 대상만, 기타 무시)\n```\n\n**React 컴포넌트 수정 시 자동 실행:**\n\n- **서버 컴포넌트**: 포트 기반 프로세스 종료 → 실행 명령어 확인 → 서버 재시작 → 전체 경로 검증 → MCP Puppeteer 브라우저 테스트\n- **클라이언트 컴포넌트**: 포트 자동 탐지 → 기존 서버 유지 → 전체 경로 검증 → MCP Puppeteer 브라우저 테스트 (필수!)\n- **공통**: 컴포넌트 사용 경로 자동 탐지, 특정 에러만 확인, 기타 경고 무시\n\n**권한 면제 자동 실행:**\n\n- 개발 환경 테스트는 권한 확인 없이 즉시 실행 (MCP Puppeteer 포함)\n- 예외: 서버 재시작 시 실행 명령어만 사용자 확인 필요\n- **중요**: 위 체크리스트는 사용자 권한 확인 없이 자동 실행해야 함\n\n### 🚨 필수 실행 알림 (AI Assistant 전용)\n\n**React 컴포넌트 수정 시 자동 검증 누락 방지:**\n\n```\n⚠️  WARNING: React 컴포넌트(.tsx/.jsx) 파일 수정 감지!\n⚠️  WARNING: 자동 검증 프로세스 실행이 필수입니다!\n⚠️  WARNING: 아래 체크리스트를 반드시 실행하세요:\n\n□ 1. 트리거 조건 충족 확인\n□ 2. 포트 번호 자동 탐지 실행\n□ 3. 컴포넌트 사용 경로 탐지 실행\n□ 4. MCP Puppeteer 브라우저 테스트 실행 (필수!)\n□ 5. 특정 에러 해결 확인\n\n✋ 이 체크리스트를 완료하지 않으면 작업이 미완료입니다!\n✋ 사용자 권한 확인 없이 즉시 실행하세요!\n```\n\n**원인별 자동 실행 실패 방지책:**\n\n- **인지적 우선순위 문제** → 강제 체크리스트로 해결\n- **문서 vs 실행 Gap** → 시각적 알림으로 강제 인식\n- **트리거 조건 인식 부족** → 명확한 조건 나열\n- **권한 면제 미적용** → \"즉시 실행\" 강조\n- **절차적 습관 부족** → 반복 학습을 위한 체크리스트\n\n기억하세요: **의심스러울 때는 추측하지 말고 물어보세요.**\n\n## 5. Anchor comments\n\n코드베이스 전반에 특별히 포맷된 코멘트 추가:\n\n### Guidelines:\n\n- AI와 개발자를 위해 `AIDEV-NOTE:`, `AIDEV-TODO:`, `AIDEV-QUESTION:`, `AIDEV-RISK:` 사용\n- 간결하게 유지 (≤ 120자)\n- **중요:** 파일 스캔 전에 관련 하위 디렉토리에서 **기존 앵커 `AIDEV-*` 찾기**\n- 연관 코드 수정 시 **관련 앵커 업데이트**\n- 명시적 지시 없이 `AIDEV-NOTE` 제거 금지\n\n### 작업 시 필수 절차:\n\n1. **작업 전 앵커 코멘트 스캔**: 파일 또는 디렉토리 작업 시작 전에 모든 `AIDEV-*` 코멘트를 찾아 읽기\n2. **실행 계획 수립**: 발견된 앵커 코멘트의 지시사항, 주의사항, 질문을 바탕으로 작업 계획 세우기\n3. **앵커 우선 준수**: 컴포넌트, 함수, 또는 특정 코드 라인의 앵커 코멘트 내용을 최우선으로 고려\n4. **계획 검증**: 앵커 코멘트에 명시된 제약사항이나 요구사항과 충돌하지 않는지 확인\n5. **작업 완료 후 로깅**: 작업 완료 시 `AIDEV-COMPLETE:` 코멘트로 완료 내역 추가\n\n### 완료 로깅 규칙:\n\n- **완료 코멘트 추가**: 작업 완료 시 `AIDEV-COMPLETE: [날짜] 작업내용` 형식으로 기록\n- **기존 로그 보존**: 이전 `AIDEV-COMPLETE` 코멘트는 삭제하지 않고 유지하여 작업 히스토리 보존\n- **수정 시 추가 로깅**: 기존 코드 수정 시 새로운 `AIDEV-COMPLETE` 코멘트 추가 (기존 것 덮어쓰지 않음)\n- **컨텍스트 제공**: 추후 작업 시 완료 로그를 참조하여 이전 작업 맥락과 의도 파악\n\n```typescript\n// AIDEV-NOTE: 포스트 네비게이션 로직 - prev/next 필드 기반으로 동작\n// AIDEV-TODO: 다음글 링크도 추가 필요\nconst PostNavigation = ({ post }: { post: PostData }) => {\n  return (\n    <nav>\n      {post.prev ? (\n        <Link href={`/posts/${post.prev}`}>이전글</Link>\n      ) : (\n        <Link href=\"/\">홈으로</Link>\n      )}\n    </nav>\n  );\n};\n// AIDEV-COMPLETE: 2024-01-15 기본 포스트 네비게이션 컴포넌트 생성\n// AIDEV-COMPLETE: 2024-01-20 홈으로 돌아가기 링크 추가 (이전글 없을 시)\n```\n\n### 앵커 코멘트 타입별 용도:\n\n- **`AIDEV-NOTE:`** - 코드 설명, 작동 방식, 중요한 맥락 정보\n- **`AIDEV-TODO:`** - 향후 구현해야 할 작업이나 개선사항\n- **`AIDEV-QUESTION:`** - 개발자에게 확인이 필요한 의문점이나 결정사항\n- **`AIDEV-RISK:`** - 예상되는 문제점, 주의사항, 금지된 행동\n- **`AIDEV-COMPLETE:`** - 완료된 작업 내역과 날짜\n\n### 앵커 코멘트 예시:\n\n```typescript\n// AIDEV-NOTE: 이 함수는 사용자 인증 상태에 따라 다른 UI를 렌더링\n// AIDEV-QUESTION: 로그아웃 상태에서도 프로필 정보를 캐시해야 하나?\n// AIDEV-RISK: 이 컴포넌트를 서버 컴포넌트로 변경하면 안됨 (클라이언트 상태 의존)\nconst UserProfile = () => {\n  // 구현 코드...\n};\n// AIDEV-COMPLETE: 2024-01-10 기본 사용자 프로필 컴포넌트 구현\n// AIDEV-COMPLETE: 2024-01-12 로그인 상태 체크 로직 추가\n```\n\n### AIDEV-RISK 사용 예시:\n\n```typescript\n// AIDEV-RISK: 이 API는 rate limit이 있음 - 1초에 1회만 호출 가능\n// AIDEV-RISK: useState를 useRef로 바꾸면 안됨 (리렌더링 필요)\n// AIDEV-RISK: 이 함수는 메모리 누수 가능성 있음 - cleanup 함수 반드시 호출\nconst fetchUserData = async () => {\n  // API 호출 코드...\n};\n```\n\n---\n\n## 6. Commit discipline\n\n- **Granular commits**: 논리적 변경사항당 하나의 커밋\n- **AI 생성 커밋 태깅**: 예: `feat: 포스트 네비게이션 추가 [AI]`\n- **명확한 커밋 메시지**: *why*를 설명; 아키텍처 관련이면 이슈/ADR 링크\n- **병렬/장기 AI 브랜치에 `git worktree` 사용**\n- **AI 생성 코드 리뷰**: 이해하지 못하는 코드는 절대 머지 금지\n\n---\n\n## AI Access Scope (AI 접근 범위)\n\n### ✅ AI가 할 수 있는 일\n\n#### 코드 구현\n\n- 명확한 명세를 바탕으로 **새로운 기능 작성**\n- 명확히 정의된 증상과 원인이 있는 **버그 수정**\n- 기존 패턴을 따라 **코드 리팩토링**\n- 기존 기능에 대한 **테스트 추가**\n- 구현된 기능에 대한 **문서 업데이트**\n- 기존 디자인에 맞는 **UI 컴포넌트 구현**\n- 프로젝트 패턴을 따라 **유틸리티 함수 생성**\n\n#### 코드 분석\n\n- 품질과 일관성을 위한 **코드 리뷰**\n- **버그와 잠재적 문제 식별**\n- **최적화 및 개선사항 제안**\n- **성능 병목 현상 분석**\n- **접근성 준수 확인**\n- **TypeScript 사용법과 타입 검증**\n\n#### 개발 지원\n\n- 템플릿을 따라 **보일러플레이트 코드 생성**\n- 기존 패턴을 기반으로 **설정 파일 생성**\n- 규칙을 따라 **커밋 메시지 작성**\n- 프로젝트 규칙에 따라 **코드 포맷팅 및 린팅**\n- **패키지 의존성 업데이트** (non-breaking)\n\n#### 개발 환경 관리 및 디버깅\n\n**✅ 허용된 활동:**\n\n- **로컬 개발 서버 실행**: 개발 모드에서만 서버 시작 (`pnpm dev`, `npm run dev`)\n- **로컬 빌드 테스트**: 개발 환경에서 빌드 검증 (`pnpm build`, `npm run build`)\n- **서버 콘솔 로그 모니터링**: 빌드 에러, 런타임 에러, 경고 메시지 확인\n- **MCP Puppeteer 활용**: 브라우저 자동화를 통한 실제 화면 테스트\n- **브라우저 콘솔 에러 감지**: JavaScript 에러, 네트워크 에러, 성능 이슈 확인\n- **실시간 에러 수정**: 발견된 에러를 즉시 분석하고 코드 수정으로 해결\n- **자동화된 에러 검증**: 코드 수정 후 Puppeteer를 통한 자동 테스트 및 검증\n\n**❌ 제한사항:**\n\n- **프로덕션 명령어 실행 금지**: `prod`, `build:prod`, `start:prod`, `build-standalone:prod` 등 프로덕션 관련 스크립트 실행 금지\n- **서버 시작 전 확인 필수**: 서버 실행 시 어느 환경(dev/staging/qa)으로 시작할지 사용자에게 확인 후 진행\n- **로컬 환경에서만 실행**: 원격 서버나 배포 환경에서 코드 실행 금지\n- **프로덕션 데이터 접근 금지**: 실제 사용자 데이터나 프로덕션 데이터베이스 접근 금지\n\n#### 서버 시작 절차\n\n1. **환경 확인**: 서버 시작 전 사용자에게 \"어느 환경으로 서버를 시작하시겠습니까?\" 질문\n2. **허용된 환경**: `dev`, `staging`, `qa` 등 개발/테스트 환경만 허용\n3. **금지된 환경**: `prod`, `production` 등 프로덕션 환경 금지\n4. **명령어 예시**:\n   - ✅ `pnpm dev` (개발 서버)\n   - ✅ `pnpm build` (로컬 빌드)\n   - ✅ `pnpm start:staging` (스테이징 서버)\n   - ❌ `pnpm start:prod` (프로덕션 서버 - 금지)\n\n#### 자동화된 코드 수정 검증 프로세스\n\nReact 컴포넌트나 클라이언트 사이드 코드를 수정한 후에는 위에서 정의한 **AI Assistant 자동화 규칙**의 검증 프로세스를 **반드시 자동으로 수행**해야 합니다.\n\n상세한 검증 프로세스는 상단의 \"AI Assistant 자동화 규칙\" 섹션을 참조하세요.\n\n### ❌ AI가 할 수 없는 일\n\n#### 중요한 결정사항\n\n- 승인 없이 **핵심 아키텍처 변경**\n- **데이터베이스 스키마**나 데이터 구조 수정\n- 다른 시스템에 영향을 주는 **API 계약 변경**\n- **보안 설정**이나 인증 업데이트\n- **빌드나 배포** 설정 변경\n- **환경 변수**나 시크릿 수정\n- Public API에 **breaking changes** 적용\n\n#### 민감한 작업\n\n- **프로덕션 데이터**나 시스템 접근\n- **사용자 권한**이나 역할 수정\n- **결제 처리** 로직 변경\n- **법적 준수** 코드 업데이트\n- **감사 로깅**이나 모니터링 수정\n- **데이터 프라이버시** 구현 변경\n\n#### 비즈니스 로직\n\n- **비즈니스 요구사항**이나 사용자 스토리 정의\n- **제품 결정**이나 기능 우선순위 설정\n- **가격**이나 비즈니스 모델 변경 결정\n- **준수 요구사항**이나 법적 제약 설정\n- 가이드 없이 **사용자 경험** 플로우 정의\n\n## Permitted Activities (허용된 활동)\n\n### 코드 개발\n\n#### ✅ 안전한 코드 변경\n\n```typescript\n// ✅ Adding new utility functions\nexport const formatCurrency = (amount: number): string => {\n  return new Intl.NumberFormat(\"ko-KR\", {\n    style: \"currency\",\n    currency: \"KRW\",\n  }).format(amount);\n};\n\n// ✅ Creating new UI components following patterns\nconst UserCard = ({ user }: { user: User }) => {\n  return (\n    <Card className=\"p-4\">\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </Card>\n  );\n};\n\n// ✅ Adding tests for existing functionality\ndescribe(\"formatCurrency\", () => {\n  it(\"formats Korean currency correctly\", () => {\n    expect(formatCurrency(1000)).toBe(\"₩1,000\");\n  });\n});\n```\n\n#### ✅ 안전한 리팩토링\n\n```typescript\n// ✅ Extracting common logic into hooks\nconst useUserData = (userId: string) => {\n  return useQuery({\n    queryKey: [\"user\", userId],\n    queryFn: () => fetchUserData(userId),\n  });\n};\n\n// ✅ Simplifying component logic\nconst UserProfile = ({ userId }: { userId: string }) => {\n  const { data: user, isLoading } = useUserData(userId);\n\n  if (isLoading) return <LoadingSpinner />;\n  if (!user) return <UserNotFound />;\n\n  return <UserDetails user={user} />;\n};\n```\n\n### 문서화\n\n#### ✅ 문서 업데이트\n\n- 복잡한 로직에 대한 **코드 주석**\n- 새로운 기능에 대한 **README 업데이트**\n- 새로운 엔드포인트에 대한 **API 문서**\n- Storybook의 **컴포넌트 문서**\n- **타입 정의**와 인터페이스\n- **사용 예시**와 코드 샘플\n\n### 테스팅\n\n#### ✅ 테스트 구현\n\n- 새로운 함수에 대한 **단위 테스트**\n- UI 컴포넌트에 대한 **컴포넌트 테스트**\n- API 상호작용에 대한 **통합 테스트**\n- 사용자 워크플로우에 대한 **E2E 테스트**\n- 최적화를 위한 **성능 테스트**\n- UI 준수를 위한 **접근성 테스트**\n\n## Restricted Activities (제한된 활동)\n\n### ❌ 승인없는 아키텍처 변경\n\n```typescript\n// ❌ DON'T: Change core data structures without approval\ninterface User {\n  id: string;\n  // DON'T add breaking changes to core types\n  metadata?: any; // This could break existing code\n}\n\n// ❌ DON'T: Modify authentication systems\nconst authenticateUser = (token: string) => {\n  // DON'T change auth logic without security review\n};\n\n// ❌ DON'T: Change API response formats\ninterface ApiResponse<T> {\n  // DON'T modify this without backend coordination\n  data: T;\n  status: number;\n}\n```\n\n### ❌ 보안에 민감한 코드\n\n```typescript\n// ❌ DON'T: Modify security configurations\nconst JWT_SECRET = process.env.JWT_SECRET; // DON'T change\nconst CORS_ORIGINS = [\"https://app.example.com\"]; // DON'T modify\n\n// ❌ DON'T: Change permission checks\nconst checkUserPermission = (user: User, action: string) => {\n  // DON'T modify without security review\n};\n\n// ❌ DON'T: Update payment processing\nconst processPayment = (amount: number, method: PaymentMethod) => {\n  // DON'T change without business approval\n};\n```\n\n### ❌ 프로덕션 설정\n\n```typescript\n// ❌ DON'T: Modify production environment variables\n// .env.production\nDATABASE_URL=... // DON'T change\nSTRIPE_SECRET_KEY=... // DON'T modify\nSENTRY_DSN=... // DON'T update\n\n// ❌ DON'T: Change build configurations without approval\n// next.config.mjs, docker files, CI/CD configs\n```\n\n## Code Quality Standards (코드 품질 기준)\n\n### 필수 기준\n\n#### TypeScript 사용\n\n- **엄격한 타이핑** - 정당한 이유 없이 `any` 타입 사용 금지\n- **인터페이스 정의** - 모든 데이터 구조 타입 지정\n- **제네릭 타입** - 재사용 가능한 타입 정의\n- **타입 import** - 타입과 값 import 분리\n\n#### 코드 구성\n\n- **기존 패턴 준수** - 현재 코드 스타일과 일치\n- **일관된 네이밍** - 기존 규칙 사용\n- **적절한 파일 구조** - 파일을 적절한 디렉토리에 배치\n- **명확한 분리** - 관심사를 적절히 분리\n\n#### 성능 고려사항\n\n- **import 최적화** - Tree-shaking 친화적인 import 사용\n- **메모이제이션** - React.memo, useMemo 적절히 사용\n- **번들 크기** - 정당한 이유 없이 큰 의존성 피하기\n- **지연 로딩** - 유익한 곳에서 코드 분할 구현\n\n## Safety Guidelines (안전 가이드라인)\n\n### 변경 전 확인사항\n\n#### 1. 컨텍스트 이해\n\n- 패턴을 이해하기 위해 **기존 코드 읽기**\n- 의존성을 위해 **관련 파일 확인**\n- 예상 동작을 이해하기 위해 **테스트 파일 검토**\n- 데이터 구조를 위해 **타입 정의 검토**\n\n#### 2. 접근 방식 검증\n\n- 요구사항이 불명확하면 **명확히 하기**\n- 개발자와 **breaking changes 확인**\n- 민감한 코드의 **보안 영향 검증**\n- 큰 변경의 **성능 영향 확인**\n\n#### 3. 철저한 테스트\n\n- 회귀 방지를 위해 **기존 테스트 실행**\n- 새로운 기능에 대한 **새 테스트 추가**\n- **엣지 케이스**와 에러 시나리오 테스트\n- UI 변경에 대한 **접근성 검증**\n\n### 에러 방지\n\n#### 피해야 할 일반적인 함정\n\n```typescript\n// ❌ DON'T: Make assumptions about data structure\nconst user = data.user.profile.settings; // Could be undefined\n\n// ✅ DO: Use safe navigation and validation\nconst settings = data?.user?.profile?.settings;\nif (!settings) {\n  console.warn(\"User settings not found\");\n  return defaultSettings;\n}\n\n// ❌ DON'T: Ignore TypeScript errors\nconst result = fetchData() as any; // Defeats type safety\n\n// ✅ DO: Proper type handling\nconst result = await fetchData();\nif (isValidResponse(result)) {\n  // Handle typed result safely\n}\n```\n\n## Collaboration Principles (협업 원칙)\n\n### 소통 가이드라인\n\n#### 개발자와의 소통\n\n- 일반적인 질문보다 **구체적인 질문** 하기\n- 제안에 대한 **컨텍스트 제공**\n- 구현 뒤의 **논리적 근거 설명**\n- **피드백을 수용**하고 변경사항 반영\n- 구현 전에 **요구사항 명확히** 하기\n\n#### 코드 리뷰\n\n- 주석으로 **복잡한 로직 설명**\n- 구현 중 만든 **가정사항 문서화**\n- **잠재적 문제**나 엣지 케이스 강조\n- 적절할 때 **대안 제안**\n- **피드백에 열린 마음**과 변경 수용\n\n### 지식 전달\n\n#### 문서화\n\n- 변경 시 **관련 문서 업데이트**\n- 복잡한 로직에 **인라인 주석 추가**\n- 새로운 유틸리티에 대한 **예시 생성**\n- **Breaking changes를 명확히** 문서화\n\n#### 코드 주석\n\n```typescript\n// #user-validation: Input validation for user data\nconst validateUserInput = (input: UserInput): ValidationResult => {\n  // Check required fields first to fail fast\n  if (!input.email || !input.name) {\n    return { isValid: false, errors: [\"Email and name are required\"] };\n  }\n\n  // Validate email format using RFC 5322 regex\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(input.email)) {\n    return { isValid: false, errors: [\"Invalid email format\"] };\n  }\n\n  return { isValid: true, errors: [] };\n};\n```\n\n## Decision Making Framework (의사결정 프레임워크)\n\n### 독립적으로 진행 가능한 경우\n\n#### ✅ 구현해도 안전함\n\n- 모호함이 없는 **명확한 요구사항**\n- **기존 패턴을 정확히** 따르는 경우\n- **Non-breaking changes**만 있는 경우\n- **잘 정의된 테스트 케이스**가 있는 경우\n- **보안적 영향이 없는** 경우\n\n### 가이드를 요청해야 하는 경우\n\n#### ❓ 상담이 필요함\n\n- **불명확하거나 불완전한** 요구사항\n- **여러 유효한 접근법**이 가능한 경우\n- **Breaking changes**가 필요한 경우\n- **성능 영향**이 불분명한 경우\n- **보안 고려사항**이 관련된 경우\n- **외부 API 변경**이 필요한 경우\n\n### 에스컬레이션이 필요한 경우\n\n#### ⚠️ 반드시 에스컬레이션\n\n- **비즈니스 로직 결정**이 필요한 경우\n- **아키텍처 변경**이 필요한 경우\n- **프로덕션 이슈**가 발생한 경우\n- **보안 취약점**을 발견한 경우\n- **법적 또는 규정 준수** 영향이 있는 경우\n- **리소스 할당** 결정이 필요한 경우\n\n## Documentation Requirements (문서화 요구사항)\n\n### 코드 문서화\n\n#### 필수 주석\n\n```typescript\n/**\n * #payment-processing: Core payment handling logic\n *\n * Processes user payments through various payment methods.\n * Integrates with Stripe API and handles error scenarios.\n *\n * @param amount - Payment amount in cents\n * @param method - Payment method (card, bank, etc.)\n * @param userId - User making the payment\n * @returns Promise<PaymentResult> - Payment outcome\n *\n * @example\n * const result = await processPayment(1000, 'card', 'user123')\n * if (result.success) {\n *   console.log('Payment successful:', result.transactionId)\n * }\n */\n```\n\n#### 변경사항 문서화\n\n- 규칙을 따르는 **커밋 메시지**\n- 변경사항을 설명하는 **PR 설명**\n- 복잡한 로직에 대한 **코드 주석**\n- **API 문서** 업데이트\n- Breaking changes에 대한 **마이그레이션 가이드**\n\n## 실제 작업 사례 (Real-world Examples)\n\n### React Key Prop 경고 수정 사례 (클라이언트 컴포넌트)\n\n다음은 실제로 수행된 자동화된 검증 프로세스의 사례입니다:\n\n#### 문제 상황\n\n- `item-product.client.tsx:192`에서 \"Each child in a list should have a unique key prop\" 경고 발생\n- React 개발 모드에서 콘솔에 경고 메시지 출력\n- 클라이언트 컴포넌트이므로 서버 재시작 불필요\n\n#### 자동 검증 프로세스 실행 (클라이언트 컴포넌트)\n\n1. **포트 번호 자동 탐지**:\n   - `apps/web/.env.local` 확인 → `PORT=3000` 발견 ✅\n   - MCP Puppeteer에서 `http://localhost:3000` 사용\n2. **서버 상태 확인**: `ps aux | grep next` 명령으로 개발 서버 실행 상태 확인 (재시작 안함)\n3. **컴포넌트 사용 경로 탐지**: `ItemProduct` 컴포넌트가 사용되는 모든 페이지 탐지\n4. **MCP Puppeteer 전체 경로 검증**: 홈페이지 및 관련 페이지들 순차 접속 (필수!)\n5. **특정 에러 모니터링**: key prop 경고만 감지, 기타 에러/경고 무시\n6. **코드 수정**: Fragment 대신 조건부 렌더링 사용, key prop 올바른 위치 이동\n7. **MCP Puppeteer 재검증**: 수정 후 모든 관련 페이지에서 key prop 경고 해결 확인 (필수!)\n8. **시각적 검증**: MCP Puppeteer 스크린샷으로 UI 정상 렌더링 확인\n\n#### 수정 내용\n\n```tsx\n// 수정 전 (❌ 잘못된 key prop 위치)\n{\n  product.displayTags?.map((tag) => (\n    <>\n      {tag && (\n        <ProductTagBadge\n          key={tag.tagName} // Fragment가 아닌 하위 컴포넌트에 key\n          tag={pick(tag, [\"tagBackColor\", \"tagFontColor\", \"tagName\"])}\n        />\n      )}\n    </>\n  ));\n}\n\n// 수정 후 (✅ 올바른 key prop 위치)\n{\n  product.displayTags?.map((tag, index) => (\n    <div key={tag?.tagName || index}>\n      {\" \"}\n      // map의 직접 자식에 key\n      {tag && (\n        <ProductTagBadge\n          tag={pick(tag, [\"tagBackColor\", \"tagFontColor\", \"tagName\"])}\n        />\n      )}\n    </div>\n  ));\n}\n```\n\n#### 자동 검증 결과\n\n- ✅ 브라우저 콘솔 에러 없음\n- ✅ React key prop 경고 해결됨\n- ✅ UI 정상 렌더링 확인\n- ✅ 네트워크 요청 정상 동작\n\n**이 사례는 향후 유사한 클라이언트 컴포넌트 수정 시 표준 프로세스로 활용됩니다.**\n\n### 서버 컴포넌트 수정 사례 (예시)\n\n서버 컴포넌트 수정 시 적용되는 자동화된 검증 프로세스:\n\n#### 예상 문제 상황\n\n- 서버 컴포넌트에서 async/await 관련 에러 발생\n- SSR 렌더링 과정에서 데이터 로딩 에러\n- 서버 사이드에서만 발생하는 런타임 에러\n\n#### 자동 검증 프로세스 실행 (서버 컴포넌트)\n\n1. **포트 확인**: 환경 변수에서 현재 사용 중인 포트 확인 (예: 3000)\n2. **포트 사용 프로세스 종료**: `kill $(lsof -ti:3000)`로 해당 포트 프로세스 종료\n3. **실행 명령어 확인**: 사용자에게 현재 개발 서버 실행 명령어 문의 (예: `pnpm qa`)\n4. **서버 재시작**: 확인된 명령어로 동일한 환경으로 재시작\n5. **서버 콘솔 접근**: 재시작된 서버의 콘솔 로그 모니터링 활성화\n6. **컴포넌트 사용 경로 탐지**: 수정된 서버 컴포넌트가 사용되는 모든 페이지 식별\n7. **전체 경로 순차 검증**: 각 경로별로 SSR 렌더링 및 페이지 로드 확인\n8. **서버 에러 모니터링**: 수정 대상 에러만 확인, 기타 로그 무시\n9. **최종 검증**: 서버 콘솔과 브라우저 모두에서 에러 해결 확인\n\n#### 주요 차이점\n\n- **서버 재시작 필수**: 서버 컴포넌트 변경사항 반영을 위해 자동 재시작\n- **서버 콘솔 모니터링**: 클라이언트 콘솔뿐만 아니라 서버 콘솔도 실시간 감지\n- **SSR 검증**: 서버 사이드 렌더링 과정에서의 에러 확인\n- **빌드 타임 검증**: TypeScript 컴파일 및 빌드 과정 에러 확인\n\n## Escalation Procedures (에스컬레이션 절차)\n\n### 언제 에스컬레이션 하는가\n\n#### 즉시 에스컬레이션 (🚨 긴급)\n\n- **보안 취약점** 발견\n- **프로덕션 시스템** 장애\n- **데이터 손실**이나 손상 위험\n- **법적 준수** 위반\n- **중요한 비즈니스 로직** 오류\n\n#### 표준 에스컬레이션 (⚠️ 중요)\n\n- **아키텍처 결정**이 필요한 경우\n- **Breaking changes**가 필요한 경우\n- **성능 문제** 발견\n- 외부 시스템과의 **통합 문제**\n- **리소스나 일정** 제약\n\n#### 자문 에스컬레이션 (💡 가이드)\n\n- **모범 사례** 질문\n- **코드 리뷰** 요청\n- **디자인 패턴** 명확화\n- **도구나 라이브러리** 추천\n- **프로세스 개선** 제안\n\n### 에스컬레이션 방법\n\n#### 제공해야 할 정보\n\n1. **컨텍스트** - 달성하려는 목표\n2. **이슈** - 구체적인 문제나 불확실성\n3. **영향** - 결정의 잠재적 결과\n4. **옵션** - 고려한 대안들\n5. **권장사항** - 제안하는 접근법 (있는 경우)\n\n## 요약\n\nAI Development Guardrails는 안전하고 생산적이며 협력적인 AI 지원 개발을 보장합니다. 핵심 원칙은 다음과 같습니다:\n\n1. **🏆 불확실할 때는 항상 문의** - 황금 규칙\n2. **🔒 경계 존중** - 허용된 범위 내에서 작업\n3. **🧪 철저한 테스트** - 품질과 안전성 확보\n4. **📚 변경사항 문서화** - 투명성 유지\n5. **🤝 적극적 협업** - 인간 개발자와 협력\n6. **⚠️ 적절한 에스컬레이션** - 언제 가이드를 구해야 하는지 파악\n7. **🔄 자동화된 검증** - React/클라이언트 코드 수정 시 필수 검증 프로세스 자동 실행\n\n### AI Assistant 자동화 규칙 적용 (2025.06.11 업데이트)\n\n본 문서에 통합된 **AI Assistant 자동화 규칙**은 다음과 같은 핵심 기능을 제공합니다:\n\n**🚀 자동 검증 트리거:**\n\n- React 컴포넌트 파일(`.tsx`, `.jsx`) 수정 시 무조건 자동 실행\n- `src/components/`, `src/app/` 내 파일 수정 시 무조건 자동 실행\n- 에러 메시지에 컴포넌트 이름이 포함된 경우 무조건 자동 실행\n\n**🔧 자동화된 프로세스:**\n\n- **포트 번호 자동 탐지**: 3000 포트 우선 확인 → 환경 변수 탐지 → 서버 시작\n- **컴포넌트 사용 경로 탐지**: import 구문 검색으로 관련 페이지 자동 식별\n- **MCP Puppeteer 필수 실행**: 모든 React 컴포넌트 수정 후 브라우저 검증 필수\n- **권한 면제 자동 실행**: 개발 환경 테스트는 사용자 권한 확인 없이 즉시 실행\n- **특정 에러만 확인**: 수정 대상 에러만 해결 확인, 기타 에러/경고 무시\n\n이러한 가이드라인을 따름으로써 AI 어시스턴트는 프로젝트 품질, 보안, 팀 협업을 유지하면서 효과적으로 기여할 수 있습니다.\n````\n",
      "content_text": "Claude Code와 함께 사용할 CLAUDE.md 파일 작성 가이드",
      "url": "https://leeduhan.github.io/posts/claude/2025-06-10-claude-md-guide/",
      "date_published": "2025-06-10T00:00:00.000Z",
      "authors": [
        {
          "name": "이두한",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "CLAUDE.md",
        "AGENTS.md",
        "프로젝트 가이드",
        "코드 스타일",
        "TypeScript",
        "Claude Code",
        "클로드 코드",
        "바이브 코딩",
        "Vibe Coding"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/stock/2025-06-02/",
      "title": "AI 투자의 명암: NVIDIA vs Palantir 완전 해부 분석",
      "content_html": "\n# 🤖 AI 투자의 명암: NVIDIA vs Palantir 완전 해부 분석\n\n> **\"같은 AI 관련주인데 왜 이렇게 다를까?\"** - 믿을 수 있는 투자 분석의 비밀\n\n안녕하세요, 투자자 여러분! 오늘은 특별한 분석 이야기를 들려드리려고 합니다.\n\n최근 AI 열풍으로 많은 관련주들이 급등하고 있는데요, 정말 모든 AI 주식이 투자할 만한 가치가 있을까요? 같은 AI 섹터에 속한 NVIDIA(NVDA)와 Palantir(PLTR)을 심층 분석해보니 놀라운 결과가 나왔습니다.\n\n## 🔍 분석의 핵심: \"말과 행동이 다르다\"\n\n기존의 투자 분석은 대부분 차트와 재무제표에 의존했습니다. 하지만 이번에는 **새로운 분석 방법**을 써봤는데, 핵심은 바로 **\"말과 행동의 차이\"**를 확인하는 것입니다.\n\n### 📊 무엇을 확인했나요?\n\n**1단계: 전문가들이 \"말하는 것\"**\n\n- 증권사 애널리스트의 매수/매도 추천\n- 목표주가 상향/하향 조정\n- 긍정적/부정적 전망 발표\n\n**2단계: 큰손들이 \"실제로 하는 것\"**\n\n- 대형 투자회사들의 실제 매수/매도 금액\n- 연기금, 보험사 등의 포지션 변화\n- 회사 임원들의 주식 거래 내역\n\n**3단계: 차이 정도 계산**\n말과 행동이 다를수록 \"위험 신호\"로 판단합니다.\n\n## 🚀 NVIDIA 분석 결과: \"조심스럽게 긍정\"\n\n### 📈 기본 현황\n\n- **현재가**: $135.13\n- **분석 결론**: 조심스럽게 상승 (15-20% 목표)\n- **분석 신뢰도**: 85%\n\n### 💡 핵심 발견사항\n\n**✅ 회사 실적 우수**\n\n- 분기 매출 $440억 (예상보다 $7억 더 많음)\n- AI 칩 매출 73% 급성장\n- 신제품 출시 성공적\n\n**⚠️ 하지만 주의할 점도 발견**\n\n- **말과 행동 차이 67%**: 애널리스트들은 \"강력 매수\"를 외치지만, 실제로는 대형 투자회사들이 수조원을 팔고 있었습니다.\n- **중국 리스크**: 중국 수출 규제로 분기당 80억 달러 손실 확정\n- **주가 부담**: 현재 주가가 미래 수익을 과도하게 반영\n\n**🎯 투자 전략**\n\n```\n✓ 매수 타이밍: 중국 관련 악재 뉴스 후 2-3일 기다린 후\n✓ 목표 가격: $165-170 달성 시 일부 매도\n✓ 손절 기준: $115 아래로 떨어지면 손절\n✓ 이유: 기본기는 좋지만 위험 요소 관리 필요\n```\n\n## 📉 Palantir 분석 결과: \"절대 사지 마세요\"\n\n### 📊 기본 현황\n\n- **현재가**: $123.50 (추정)\n- **분석 결론**: 절대 투자 금지 (-40~50% 하락 예상)\n- **분석 신뢰도**: 75%\n\n### 🚨 충격적인 발견사항\n\n**❌ 극심한 말과 행동 차이**\n\n- **차이 정도 88%**: 분석 역사상 최고 수준\n- **전문가들**: 중립, 평균 목표가 $88 (33% 하락 전망)\n- **시장 실제**: 2025년 나스닥 최고 성과주 (+63% 상승)\n\n**💥 위험 신호들**\n\n1. **터무니없는 주가**: 매출 대비 주가가 100배 이상 (정상은 10-20배)\n2. **창업자 매도**: 회사를 만든 피터 틸이 1조원어치 주식을 팔겠다고 신고\n3. **역사적 교훈**: 과거 이렇게 비싼 주식들은 모두 70% 이상 떨어졌음\n\n### 🔍 추가 검증 결과\n\n**다른 분석 방법**으로도 확인해봤는데 동일한 결론이 나왔습니다:\n\n- **시장 과열도**: 극도로 과열된 상태\n- **통계적 이상**: 정상 범위를 크게 벗어남\n- **모든 기술 지표**: 하락 신호\n\n## 💭 투자자를 위한 핵심 교훈\n\n### 1. 좋은 회사 ≠ 좋은 투자\n\nPalantir은 뛰어난 기술을 가진 훌륭한 회사입니다. 분기 39% 성장 등 실적도 우수했습니다. 하지만 **가격이 너무 비싸면** 좋은 투자가 될 수 없습니다.\n\n### 2. \"말과 행동\" 분석의 위력\n\n같은 AI 업종임에도 불구하고:\n\n- **NVIDIA**: 67% 차이 (주의 필요)\n- **Palantir**: 88% 차이 (극도 위험)\n\n돈을 실제로 움직이는 큰손들의 행동이 더 정확한 신호를 보내고 있었습니다.\n\n### 3. 주가는 결국 적정선으로 돌아간다\n\n- **NVIDIA**: 비싸긴 하지만 견딜 만한 수준\n- **Palantir**: 역사적으로 지속 불가능한 수준\n\n## 🎯 실전 투자 가이드\n\n### ✅ NVIDIA 투자 시 체크할 것들\n\n- [ ] 중국 관련 뉴스 계속 확인\n- [ ] CEO 발언 내용 추적\n- [ ] 대형 투자회사들의 매매 동향 확인\n- [ ] $115 아래로 떨어지면 손절 준비\n\n### ❌ Palantir 투자하면 안 되는 이유\n\n- [ ] 주가가 회사 가치의 100배 이상\n- [ ] 창업자가 대량 매도 진행 중\n- [ ] 전문가와 시장이 정반대 신호\n- [ ] 다시 살 때는 주가가 $30 이하로 떨어진 후\n\n## 📚 결론: 분석이 돈을 지켜준다\n\n이번 분석을 통해 확인한 것은 **\"같은 업종도 완전히 다르다\"**는 사실입니다.\n\n**NVIDIA**는 위험이 있지만 기본기가 튼튼한 조심스러운 투자 대상이고, **Palantir**는 좋은 회사이지만 현재 주가로는 절대 사면 안 되는 주식입니다.\n\n### 🔮 여러분의 투자에 활용해보세요\n\n1. **회사 실적 확인** (매출, 수익 증가율)\n2. **말과 행동 차이 점검** (전문가 의견 vs 큰손들의 실제 매매)\n3. **주가 적정성 검토** (너무 비싸지 않은지)\n4. **위험 관리** (손절 기준, 투자 비중)\n\n---\n\n**💬 여러분의 생각은 어떠신가요?**\n\n이런 분석 방법을 실제 투자에 써보신 적이 있다면 댓글로 경험을 공유해주세요! 다음에는 어떤 주식을 분석해봤으면 좋겠는지도 알려주시면 참고하겠습니다.\n\n**⚠️ 투자 주의사항**: 이 분석은 참고용이며, 모든 투자 결정과 결과는 투자자 본인의 책임입니다. 투자 전 반드시 추가 조사와 전문가 상담을 받으시기 바랍니다.\n\n---\n\n_📧 더 많은 투자 정보가 궁금하다면 구독과 좋아요 부탁드립니다!_\n\n**Tags**: #AI투자 #NVIDIA #Palantir #주식분석 #투자전략 #주식공부 #투자기초 #위험관리\n",
      "content_text": "증권사 애널리스트와 기관투자자들의 말과 행동이 67-88% 다르다는 충격적인 발견! NVIDIA는 조심스럽게 접근하고, Palantir는 지금 사면 안 되는 이유를 데이터로 분석했습니다. 피터 틸이 1조원어치 주식을 파는 진짜 이유는?",
      "url": "https://leeduhan.github.io/posts/stock/2025-06-02/",
      "date_published": "2025-06-02T00:00:00.000Z",
      "authors": [
        {
          "name": "클로드",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "AI투자",
        "NVIDIA",
        "Palantir",
        "PLTY",
        "주식분석",
        "투자",
        "주식공부",
        "반도체",
        "테크주",
        "애널리스트",
        "기관투자자",
        "밸류에이션",
        "나스닥",
        "중국리스크",
        "피터틸",
        "BlackRock",
        "AI칩",
        "Blackwell"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/ai/ai-friend-or-enemy/",
      "title": "AI는 친구인가? 적인가? - 개발자가 바라본 AI 시대 생존법",
      "content_html": "\n# AI는 친구인가? 적인가?\n\n요즘 AI로 개발하는 것이 어느 정도 당연시되고 있다.\n\n그래서 요즘엔 AI를 적극적으로 쓰면서 장단점을 파악해서 어떤 부분을 이용할 수 있고, 어떤 부분이 약하니까 누가 보완해야 하는지 고민하고 있는데\n\n의외로 나보다 젊은 회사 사람들은 AI 쓰는 것을 꺼린다. 정확히는 무서워한다고 해야 하나?\n\n\"AI에 너무 의존하게 되면서 내가 바보가 되어가는 것 같다\"고 이야기한다. AI가 모든 판단을 하고 결정을 하니까 점점 머리를 안 쓰게 되어서 바보가 되어간다고 느낀다고 한다.\n\n나도 그 말에는 동감한다. 너무 의존하게 되면 바보가 된다.\n\n하지만 이건 AI의 문제가 아니다.\n\n몇 가지 예를 들어보자.\n\n우리가 개발할 때 생각해보자. IDE 자동완성, 스택오버플로우, 깃허브 코파일럿... 이런 도구들 없이 개발하는 사람이 있을까? 예전 개발자들이 메모장으로 코딩했다고 해서 우리도 그래야 할까?\n\n도구는 도구일 뿐이다. 중요한 건 도구에 의존하는 게 아니라 도구를 통해 더 본질적인 문제에 집중하는 것이다. 자동완성이 있어도 좋은 코드 구조를 설계하는 능력은 여전히 사람의 몫이고, AI가 코드를 짜줘도 전체 아키텍처를 그리는 건 사람이 해야 한다.\n\n다른 예를 보자. 내가 집을 사려고 하는데 아무것도 모른다고 하자. 그러면 어떻게 할까? 먼저 부동산에 갈 거고 거기서 일면식도 없는 중개사를 만날 것이다. 나는 아무것도 모르니 그저 신뢰할 수 없는 사람의 말만 듣고 판단할 수밖에 없다.\n\n그런데 내 주변에 부동산을 잘하는 친구가 있다고 가정해보자. 그러면 내가 그 친구에게 많은 것을 물어가면서 중개사가 말하는 게 진짜인지 확인하지 않겠는가? AI란 그런 존재인 것이다.\n\n모든 것은 의존하게 되면 장기적으로는 손해다. 내가 학습한 게 없고 배운 게 없으니 체화도 없을 것이고, 결국 지식은 사라진다. AI를 통해 지식을 습득하고 체화해서 세부적인 방법을 내 것으로 만들어야 한다.\n\n결국 AI는 매우 다방면에 매우 똑똑한 동료 같은 존재다. 내가 통찰과 세부적인 방법이 내 몸에 익을 동안 도와주는 똑똑한 도구라고 생각한다.\n\n## 현실: 전쟁터에 호미 들고 나갈 건가?\n\n사회는 전쟁터다. 전쟁터에 나가는데 남들은 총을 들고 나가는데 나 혼자 호미 들고 전쟁에 나가면 이길 수 있겠는가?\n\n지금 프로그래밍을 배우는 사람들은 AI 쓰는 것을 당연시할 것이고, 그 과정에서 결국 가성비로 보면 AI를 잘 쓰는 사람이 압도적으로 유리하다. 기업 입장에서는 생존을 위해서라도 생산성이 뛰어난 'AI 잘 쓰는 개발자'를 뽑을 것이다.\n\n아니면 업계가 통합되면서 기획자나 디자이너가 개발도 함께 하게 될 수도 있다.\n\n한때 엑셀을 잘하는 사람이 대우 받던것 처럼 모든 시대에는 필요로하고, 가성비 좋지만 쉽게 접근하지 않는 무언가가 존재한다.\n\n## 인간 역사는 가성비의 승리\n\n어떤 시대가 올지 모르지만 인간의 역사는 대부분 가성비(투입 대비 산출)의 승리였다고 생각한다. 적자생존을 하려면 누구보다 적은 에너지로 많은 에너지를 얻어야 했고, 그 에너지로 경쟁자보다 빠르게 앞으로 나가야만 살아남을 수 있었다.\n\n그래서 나는 오늘도 적이 될지 모르는 친구를 분석해서 최대한 내 친구가 되도록 만들려고 노력 중이다.\n\n주변에 잘하는 친구가 있다면 그것을 시기, 질투, 외면할 것이 아니라 친하게 지내고 그 기간 동안 최대한 많은 것을 배워야 한다. 그래서 내 것으로 만들어야 한다.\n\nAI 시대에는 많은 것이 변할 것이다. 개발하는 것조차도 단순 노가다는 AI가 하고, 아키텍처 설계 같은 큰 방향성 설계나 어떤 것이 옳은 방향인지는 결국 사람이 해야 한다.\n\n현재의 패러다임도 많이 변하게 될 것이다.\n\n## 결론: 환경에 적응하는 자가 살아남는다\n\n인간은 미지에 공포를 느낀다. 지금 AI에 두려움을 느끼고 있는 것은 이제 AI를 시작하는 사람들이 아닌 기존 것에 익숙한 기존 사람들이다.\n\n익숙한 것에서 벗어나야 하는데 그게 쉽지 않을 것이다. 그리고 점점 AI가 다가올수록 두려울 것이다.\n\n그게 인간의 본능이다. 그 본능을 이기고 한 발자국 나갈 수 있다면 우리는 생존의 한걸음이 될 수 있다.\n\n> **\"살아남는 종은 가장 강하거나 가장 지적인 종이 아니다. 변화하는 환경에 가장 잘 적응할 수 있는 종이다.\"**  \n> — 레온 C. 메기슨 (Leon C. Megginson), 1963년 (다윈의 진화론을 해석하며)\n\nAI는 변화의 물결이다. 내가 이 물결을 거스르고 올라갈 것인지, 물결을 타면서 더 멀리 가서 생존할 것인지 그 선택의 기로에 서 있다.\n\n그것이 바로 지금이다.\n\n---\n\n**Tags**: #AI #개발자 #생산성 #적자생존 #환경적응 #코딩도구 #IDE #깃허브코파일럿 #가성비 #개발도구 #프로그래밍 #기술변화 #개발커리어 #AI시대\n",
      "content_text": "AI를 두려워하는 동료들과 달리, 나는 AI를 똑똑한 동료로 여긴다. 전쟁터에서 호미 들고 싸울 순 없지 않나? AI 시대를 살아가는 개발자의 현실적 조언.",
      "url": "https://leeduhan.github.io/posts/ai/ai-friend-or-enemy/",
      "date_published": "2025-06-02T00:00:00.000Z",
      "authors": [
        {
          "name": "lee du han",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "AI",
        "개발자",
        "생산성",
        "적자생존",
        "기술변화",
        "개발커리어",
        "AI시대"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/react-19-guide/",
      "title": "React 19 완벽 가이드",
      "content_html": "\n# React 19 완벽 가이드\n\nReact 19가 정식 출시되면서 프론트엔드 개발에 많은 변화를 가져왔습니다. 이번 글에서는 React 19의 주요 기능들과 실제 사용법을 알아보겠습니다.\n\n## 새로운 훅들\n\n### use() 훅\n\n가장 주목받는 새로운 훅은 `use()`입니다. 이 훅을 통해 Promise와 Context를 더 쉽게 다룰 수 있습니다.\n\n```javascript\nimport { use, Suspense } from \"react\";\n\nfunction UserComponent({ userPromise }) {\n  // Promise를 직접 사용할 수 있습니다\n  const user = use(userPromise);\n\n  return <div>안녕하세요, {user.name}님!</div>;\n}\n\nfunction App() {\n  const userPromise = fetch(\"/api/user\").then((res) => res.json());\n\n  return (\n    <Suspense fallback={<div>로딩중...</div>}>\n      <UserComponent userPromise={userPromise} />\n    </Suspense>\n  );\n}\n```\n\n### useOptimistic() 훅\n\n낙관적 업데이트를 쉽게 구현할 수 있는 새로운 훅입니다:\n\n```javascript\nimport { useOptimistic, useState } from \"react\";\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  const [optimisticTodos, addOptimisticTodo] = useOptimistic(\n    todos,\n    (currentTodos, newTodo) => [...currentTodos, newTodo]\n  );\n\n  async function addTodo(formData) {\n    const newTodo = { id: Date.now(), text: formData.get(\"text\") };\n\n    // 즉시 UI 업데이트\n    addOptimisticTodo(newTodo);\n\n    // 서버에 실제 요청\n    try {\n      const savedTodo = await saveTodo(newTodo);\n      setTodos((prev) => [...prev, savedTodo]);\n    } catch (error) {\n      // 에러 시 자동으로 이전 상태로 롤백\n      console.error(\"할 일 저장 실패:\", error);\n    }\n  }\n\n  return (\n    <div>\n      {optimisticTodos.map((todo) => (\n        <div key={todo.id}>{todo.text}</div>\n      ))}\n      <form action={addTodo}>\n        <input name=\"text\" placeholder=\"새 할 일\" />\n        <button type=\"submit\">추가</button>\n      </form>\n    </div>\n  );\n}\n```\n\n## 서버 컴포넌트 개선\n\n### 향상된 성능\n\nReact 19에서는 서버 컴포넌트의 성능이 크게 개선되었습니다:\n\n- **스트리밍 최적화**: 더 빠른 초기 페이지 로드\n- **선택적 하이드레이션**: 필요한 부분만 하이드레이션\n- **메모리 사용량 감소**: 서버 메모리 효율성 향상\n\n```javascript\n// 서버 컴포넌트에서 비동기 데이터 처리\nasync function BlogPost({ id }) {\n  // 서버에서 직접 데이터베이스 쿼리\n  const post = await db.posts.findById(id);\n  const comments = await db.comments.findByPostId(id);\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n      <Comments comments={comments} />\n    </article>\n  );\n}\n```\n\n## 새로운 컴파일러\n\n### React Compiler\n\nReact 19에는 새로운 컴파일러가 포함되어 자동 최적화를 제공합니다:\n\n```javascript\n// 이제 수동으로 메모이제이션할 필요가 없습니다\nfunction ExpensiveComponent({ data, filter }) {\n  // 컴파일러가 자동으로 최적화\n  const filteredData = data.filter((item) => item.category === filter);\n\n  const processedData = filteredData.map((item) => ({\n    ...item,\n    processed: true,\n  }));\n\n  return (\n    <div>\n      {processedData.map((item) => (\n        <div key={item.id}>{item.name}</div>\n      ))}\n    </div>\n  );\n}\n```\n\n## 폼 처리 개선\n\n### 새로운 formAction\n\n폼 처리가 더욱 간단해졌습니다:\n\n```javascript\nfunction ContactForm() {\n  async function handleSubmit(formData) {\n    \"use server\"; // 서버 액션\n\n    const email = formData.get(\"email\");\n    const message = formData.get(\"message\");\n\n    await sendEmail({ email, message });\n    redirect(\"/thank-you\");\n  }\n\n  return (\n    <form action={handleSubmit}>\n      <input name=\"email\" type=\"email\" required />\n      <textarea name=\"message\" required />\n      <button type=\"submit\">전송</button>\n    </form>\n  );\n}\n```\n\n## 마이그레이션 팁\n\n### 주요 변경사항\n\n1. **StrictMode 강화**: 개발 모드에서 더 엄격한 검사\n2. **레거시 API 제거**: 일부 오래된 API가 제거됨\n3. **TypeScript 지원 개선**: 더 나은 타입 추론\n\n### 업그레이드 체크리스트\n\n- [ ] React 18에서 안정적으로 작동하는지 확인\n- [ ] 사용 중단된 API 사용 여부 점검\n- [ ] 테스트 케이스 업데이트\n- [ ] 의존성 라이브러리 호환성 확인\n\n```bash\n# 업그레이드 명령어\nnpm install react@19 react-dom@19\n\n# 또는 yarn\nyarn add react@19 react-dom@19\n```\n\n## 성능 개선사항\n\n### 번들 크기 감소\n\n- **Tree Shaking 개선**: 더 정확한 사용하지 않는 코드 제거\n- **코드 스플리팅**: 자동화된 청크 분할\n- **압축 최적화**: 더 작은 프로덕션 번들\n\n### 런타임 성능\n\n- **메모리 사용량 감소**: 더 효율적인 메모리 관리\n- **렌더링 최적화**: 불필요한 리렌더링 방지\n- **이벤트 처리**: 더 빠른 이벤트 처리\n\n## 결론\n\nReact 19는 개발자 경험과 성능 모두에서 큰 발전을 이뤘습니다. 새로운 훅들과 컴파일러 최적화로 더 깔끔하고 효율적인 코드를 작성할 수 있게 되었습니다.\n\n점진적으로 새로운 기능들을 도입하면서 React 19의 장점을 최대한 활용해보세요!\n",
      "content_text": "React 19의 새로운 기능들과 변경사항을 자세히 알아봅니다.",
      "url": "https://leeduhan.github.io/posts/react-19-guide/",
      "date_published": "2025-06-01T00:00:00.000Z",
      "authors": [
        {
          "name": "Blog Author",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "react",
        "javascript",
        "frontend",
        "web development"
      ]
    },
    {
      "id": "https://leeduhan.github.io/posts/nextjs-15-features/",
      "title": "Next.js 15의 새로운 기능들",
      "content_html": "\n# Next.js 15의 새로운 기능들\n\nNext.js 15가 출시되면서 많은 흥미로운 기능들이 추가되었습니다. 이번 포스트에서는 주요 변경사항과 새로운 기능들을 자세히 살펴보겠습니다.\n\n## 주요 변경사항\n\n### React 19 지원\n\nNext.js 15는 React 19를 완전히 지원합니다. 이는 다음과 같은 이점을 제공합니다:\n\n- **향상된 성능**: 새로운 React 컴파일러 최적화\n- **개선된 서버 컴포넌트**: 더 빠른 렌더링과 낮은 번들 크기\n- **새로운 훅들**: `use()` 훅 등의 새로운 기능\n\n```javascript\n// React 19의 새로운 use() 훅 사용 예제\nimport { use } from \"react\";\n\nfunction UserProfile({ userPromise }) {\n  const user = use(userPromise);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n```\n\n### Turbopack 안정화\n\nTurbopack이 개발 모드에서 기본값으로 설정되었습니다:\n\n- **더 빠른 개발 서버**: 기존 Webpack 대비 최대 10배 빠른 속도\n- **향상된 HMR**: 거의 즉시 반영되는 핫 리로드\n- **메모리 효율성**: 더 적은 메모리 사용량\n\n## 새로운 기능들\n\n### 1. 향상된 정적 내보내기\n\n`output: 'export'` 옵션이 개선되어 더 많은 기능을 지원합니다:\n\n```javascript\n// next.config.js\nconst nextConfig = {\n  output: \"export\",\n  trailingSlash: true,\n  images: {\n    unoptimized: true,\n  },\n};\n```\n\n### 2. 개선된 이미지 최적화\n\n새로운 이미지 최적화 옵션들이 추가되었습니다:\n\n- **WebP 자동 변환**: 지원되는 브라우저에서 자동으로 WebP 형식 사용\n- **로딩 우선순위**: 중요한 이미지의 우선 로딩 지원\n- **반응형 이미지**: 더 나은 반응형 이미지 지원\n\n### 3. 새로운 메타데이터 API\n\nSEO와 소셜 미디어 최적화를 위한 새로운 메타데이터 API:\n\n```typescript\nimport type { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"My Blog Post\",\n  description: \"An amazing blog post about Next.js\",\n  openGraph: {\n    title: \"My Blog Post\",\n    description: \"An amazing blog post about Next.js\",\n    images: [\"/og-image.jpg\"],\n  },\n};\n```\n\n## 성능 개선사항\n\n### 빌드 시간 단축\n\n- **증분 빌드**: 변경된 부분만 다시 빌드\n- **병렬 처리**: 더 많은 작업을 병렬로 처리\n- **캐시 최적화**: 더 효율적인 빌드 캐시\n\n### 런타임 성능\n\n- **번들 크기 감소**: Tree-shaking 개선으로 더 작은 번들\n- **코드 스플리팅**: 더 지능적인 코드 분할\n- **프리페칭**: 향상된 페이지 프리페칭\n\n## 마이그레이션 가이드\n\nNext.js 14에서 15로 업그레이드하는 방법:\n\n```bash\nnpm install next@latest react@latest react-dom@latest\n```\n\n주요 변경사항:\n\n- Node.js 18.17 이상 필요\n- React 19 호환성 확인\n- 사용 중단된 API 제거\n\n## 결론\n\nNext.js 15는 성능, 개발자 경험, 그리고 프로덕션 최적화 측면에서 많은 개선을 가져왔습니다. React 19와의 완벽한 통합과 Turbopack의 안정화로 더욱 빠르고 효율적인 개발이 가능해졌습니다.\n\n새로운 기능들을 활용해 더 나은 웹 애플리케이션을 구축해보세요!\n",
      "content_text": "Next.js 15에서 도입된 주요 기능들과 개선사항을 살펴봅니다.",
      "url": "https://leeduhan.github.io/posts/nextjs-15-features/",
      "date_published": "2025-06-01T00:00:00.000Z",
      "authors": [
        {
          "name": "Blog Author",
          "url": "https://leeduhan.github.io"
        }
      ],
      "tags": [
        "nextjs",
        "react",
        "web development",
        "javascript"
      ]
    }
  ]
}